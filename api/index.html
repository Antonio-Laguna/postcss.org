<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta property="og:type" content="article"><meta property="og:url" content="http://postcss.org/"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@postcss"><meta name="twitter:creator" content="@postcss"><meta name="description" content="Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins."><link rel="icon" type="image/x-icon" href="/favicon.8a995d15.ico"><link rel="icon" href="/logo.edbca69e.svg" type="image/svg+xml" sizes="any"><meta property="og:image" content="/og.2f89ad6b.jpg"><title>PostCSS API</title><style>*{padding:0;margin:0;list-style:none}*,:after,:before{box-sizing:inherit}html{box-sizing:border-box;font-family:Fira Sans,sans-serif;font-size:18px;background:#f4f2ed;-webkit-text-size-adjust:100%;-moz-text-size-adjust:100%;text-size-adjust:100%}@font-face{font-family:Fira Sans;font-weight:500;src:url(fira-sans-500.e21eaed3.woff2) format("woff2");font-display:swap}@font-face{font-family:Fira Sans;font-weight:400;src:url(fira-sans-400.c2a591fb.woff2) format("woff2");font-display:swap}@font-face{font-family:Fira Sans;font-weight:300;src:url(fira-sans-300.959de6fe.woff2) format("woff2");font-display:swap}.nav{position:absolute;top:0;right:0;left:0;font-weight:500;background-color:rgba(0,0,0,.4)}@media (min-width:976px){.nav{right:auto;width:50%}}.nav_items{display:flex;align-items:center;justify-content:center;height:3rem;padding:0 1rem}@media (min-width:976px){.nav_items{justify-content:flex-start}}.nav_item:not(:last-child){margin-right:.8rem}@media (min-width:976px){.nav_item:not(:last-child){margin-right:1.5rem}}.nav_link{font-size:.875rem;line-height:1.425;color:#eee7df;text-decoration:none}.nav_link:hover{text-decoration:underline}.hero:before,.nav{position:fixed}.hero:before{top:0;right:0;left:0;height:3rem;content:"";background:#4d4634 no-repeat 50% 4%;background-size:cover}@media (min-width:976px){.hero:before{background-image:url(alchemy.e26b26f8.jpg)}}.hero_home{position:fixed;top:.5rem;z-index:2}.hero_home:hover{opacity:.7}@media (min-width:976px){.hero_home{left:50%;margin-left:-1rem}}@media (max-width:975px){.hero_home{left:.5rem;margin-left:0}}.hero_logo{width:2rem;height:2rem}.socials{font-weight:500;background-color:rgba(0,0,0,.68)}@media (min-width:976px){.socials{position:absolute;top:0;right:0;width:50%;margin-top:0;background-color:rgba(0,0,0,.4)}}.socials_items{display:flex;align-items:center;justify-content:center;height:3rem;padding:0 1rem}@media (min-width:976px){.socials_items{justify-content:flex-end}}.socials_item:not(:last-child){margin-right:1.5rem}.socials_link{padding-left:1.25rem;font-size:.875rem;line-height:1.425;color:#eee7df;text-decoration:none;background-repeat:no-repeat;background-position:0}.socials_link:hover{text-decoration:underline}.socials_link.is-open-collective{background-image:url(open-collective.9c36423f.svg)}.socials_link.is-twitter{background-image:url(twitter.af9bb3c8.svg)}.socials_link.is-gitter{background-image:url(gitter.6f25d874.svg)}.socials_link.is-github{background-image:url(github.47880150.svg)}@media (min-width:976px){.socials{position:fixed}}.footer{padding:3rem 1rem;background:#f4f2ed}.footer_inner{text-align:center}@media (min-width:501px){.footer_inner{display:flex;flex-direction:row;justify-content:space-between;max-width:50rem;margin:0 auto;text-align:initial}}.footer_info{margin-bottom:.25rem;font-size:.8125rem;line-height:2.15;color:rgba(72,70,62,.77)}.footer_issue{margin-bottom:1rem}.footer_report{display:inline-block;margin-left:.25rem;color:rgba(72,70,62,.77);text-decoration:underline}.footer_report:hover{text-decoration:none}@media (min-width:501px){.footer_inner{max-width:70rem;padding:2rem 2rem 1rem 13rem}}.doc{max-width:70rem;padding:2rem 2rem 1rem;margin:0 auto}@media (min-width:976px){.doc{padding:2rem 2rem 1rem 13rem}.doc:first-child{padding-top:5rem}}@media (max-width:975px){.doc{padding:2rem 1rem 1rem}.doc:first-child{padding-top:4rem}}.doc_subtitle,.doc_title{margin-bottom:1rem;font-size:1.5625rem;font-weight:400;line-height:1.28;color:#3f526b}.doc_title{font-size:1.5625rem}.doc_subtitle{margin-top:2rem;font-size:1.25rem}.doc_prefix{font-weight:300;opacity:.5}.doc>p,.doc>pre,.doc>table,.doc>ul{margin-bottom:1rem}.doc>ul li{margin-bottom:.5rem;list-style:disc}.doc>p code,.doc>table code{font-family:Monaco,Menlo,Fira Mono,monospace;font-size:.9rem}.doc>p a,.doc>table a,.doc>ul a{color:inherit}.doc>p a:hover,.doc>table a:hover,.doc>ul a:hover{text-decoration:none}.doc>table{width:calc(100% + 1rem);margin:-.5rem -.5rem 1rem;border-collapse:collapse}@media (max-width:975px){.doc>table tr{display:grid;grid-template-rows:auto auto;grid-template-columns:auto auto}}.doc>table tr:nth-child(2n){background:#faf8f5}.doc>table th{padding:.5rem;font-weight:300;color:#3f526b;text-align:left}@media (max-width:975px){.doc>table th{display:none}}.doc>table td{vertical-align:top}@media (min-width:976px){.doc>table td{padding:.5rem}}@media (max-width:975px){.doc>table td{padding:.5rem}.doc>table td:first-child{padding-right:0}.doc>table td:nth-child(2){padding-left:0;text-align:right}.doc>table td:nth-child(3){grid-column-start:1;grid-column-end:3;padding-top:0}}html{scroll-padding-top:70px}.code{display:block;padding:.75rem;overflow:auto;overflow-y:hidden;font-family:Monaco,Menlo,Fira Mono,monospace;font-size:.825rem;line-height:1.6;color:rgba(0,0,0,.84);background:#fff;border:1px solid #c8c8c8;border-radius:4px}.code_built_in,.code_keyword{color:#c82829}.code_attr{color:#917100}.code_string{color:#667e00}.code_comment{color:#757772}.sidemenu{position:fixed;top:3rem;bottom:0;left:0;width:11rem;overflow-y:auto;background:#faf8f5}@media (max-width:975px){.sidemenu{display:none}}.sidemenu_child,.sidemenu_section{display:block;text-decoration:none}.sidemenu_section{padding:.4rem 0 .4rem 1rem;margin-top:.5rem;font-weight:700;color:#3f526b}.sidemenu_child{padding:.2rem 0 .2rem 2rem;font-size:14px;color:#3f526b}.sidemenu_child:hover,.sidemenu_section:hover{background:#fff}.gitter-open-chat-button{font-family:Fira Sans,sans-serif;font-size:14px;background-color:#dd3808}.gitter-open-chat-button:focus,.gitter-open-chat-button:hover{background-color:#c73307}</style><script>((window.gitter={}).chat={}).options={room:"postcss/postcss"};</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async></script></head><body><nav class="sidemenu"><ul><li><a href="#default" class="sidemenu_section">default</a><ul><li><a href="#default-name" class="sidemenu_child">name</a></li><li><a href="#default-nodes" class="sidemenu_child">nodes</a></li><li><a href="#default-params" class="sidemenu_child">params</a></li><li><a href="#default-parent" class="sidemenu_child">parent</a></li><li><a href="#default-raws" class="sidemenu_child">raws</a></li><li><a href="#default-source" class="sidemenu_child">source</a></li><li><a href="#default-type" class="sidemenu_child">type</a></li><li><a href="#default-first" class="sidemenu_child">first</a></li><li><a href="#default-last" class="sidemenu_child">last</a></li><li><a href="#default-after" class="sidemenu_child">after()</a></li><li><a href="#default-append" class="sidemenu_child">append()</a></li><li><a href="#default-before" class="sidemenu_child">before()</a></li><li><a href="#default-cleanraws" class="sidemenu_child">cleanRaws()</a></li><li><a href="#default-clone" class="sidemenu_child">clone()</a></li><li><a href="#default-cloneafter" class="sidemenu_child">cloneAfter()</a></li><li><a href="#default-clonebefore" class="sidemenu_child">cloneBefore()</a></li><li><a href="#default-each" class="sidemenu_child">each()</a></li><li><a href="#default-error" class="sidemenu_child">error()</a></li><li><a href="#default-every" class="sidemenu_child">every()</a></li><li><a href="#default-index" class="sidemenu_child">index()</a></li><li><a href="#default-insertafter" class="sidemenu_child">insertAfter()</a></li><li><a href="#default-insertbefore" class="sidemenu_child">insertBefore()</a></li><li><a href="#default-next" class="sidemenu_child">next()</a></li><li><a href="#default-positioninside" class="sidemenu_child">positionInside()</a></li><li><a href="#default-prepend" class="sidemenu_child">prepend()</a></li><li><a href="#default-prev" class="sidemenu_child">prev()</a></li><li><a href="#default-push" class="sidemenu_child">push()</a></li><li><a href="#default-raw" class="sidemenu_child">raw()</a></li><li><a href="#default-remove" class="sidemenu_child">remove()</a></li><li><a href="#default-removeall" class="sidemenu_child">removeAll()</a></li><li><a href="#default-removechild" class="sidemenu_child">removeChild()</a></li><li><a href="#default-replacevalues" class="sidemenu_child">replaceValues()</a></li><li><a href="#default-replacewith" class="sidemenu_child">replaceWith()</a></li><li><a href="#default-root" class="sidemenu_child">root()</a></li><li><a href="#default-some" class="sidemenu_child">some()</a></li><li><a href="#default-tojson" class="sidemenu_child">toJSON()</a></li><li><a href="#default-tostring" class="sidemenu_child">toString()</a></li><li><a href="#default-walk" class="sidemenu_child">walk()</a></li><li><a href="#default-walkatrules" class="sidemenu_child">walkAtRules()</a></li><li><a href="#default-walkcomments" class="sidemenu_child">walkComments()</a></li><li><a href="#default-walkdecls" class="sidemenu_child">walkDecls()</a></li><li><a href="#default-walkrules" class="sidemenu_child">walkRules()</a></li><li><a href="#default-warn" class="sidemenu_child">warn()</a></li></ul></li><li><a href="#default" class="sidemenu_section">default</a><ul><li><a href="#default-parent" class="sidemenu_child">parent</a></li><li><a href="#default-raws" class="sidemenu_child">raws</a></li><li><a href="#default-source" class="sidemenu_child">source</a></li><li><a href="#default-text" class="sidemenu_child">text</a></li><li><a href="#default-type" class="sidemenu_child">type</a></li><li><a href="#default-after" class="sidemenu_child">after()</a></li><li><a href="#default-before" class="sidemenu_child">before()</a></li><li><a href="#default-cleanraws" class="sidemenu_child">cleanRaws()</a></li><li><a href="#default-clone" class="sidemenu_child">clone()</a></li><li><a href="#default-cloneafter" class="sidemenu_child">cloneAfter()</a></li><li><a href="#default-clonebefore" class="sidemenu_child">cloneBefore()</a></li><li><a href="#default-error" class="sidemenu_child">error()</a></li><li><a href="#default-next" class="sidemenu_child">next()</a></li><li><a href="#default-positioninside" class="sidemenu_child">positionInside()</a></li><li><a href="#default-prev" class="sidemenu_child">prev()</a></li><li><a href="#default-raw" class="sidemenu_child">raw()</a></li><li><a href="#default-remove" class="sidemenu_child">remove()</a></li><li><a href="#default-replacewith" class="sidemenu_child">replaceWith()</a></li><li><a href="#default-root" class="sidemenu_child">root()</a></li><li><a href="#default-tojson" class="sidemenu_child">toJSON()</a></li><li><a href="#default-tostring" class="sidemenu_child">toString()</a></li><li><a href="#default-warn" class="sidemenu_child">warn()</a></li></ul></li><li><a href="#default" class="sidemenu_section">default</a><ul><li><a href="#default-nodes" class="sidemenu_child">nodes</a></li><li><a href="#default-parent" class="sidemenu_child">parent</a></li><li><a href="#default-raws" class="sidemenu_child">raws</a></li><li><a href="#default-source" class="sidemenu_child">source</a></li><li><a href="#default-type" class="sidemenu_child">type</a></li><li><a href="#default-first" class="sidemenu_child">first</a></li><li><a href="#default-last" class="sidemenu_child">last</a></li><li><a href="#default-after" class="sidemenu_child">after()</a></li><li><a href="#default-append" class="sidemenu_child">append()</a></li><li><a href="#default-before" class="sidemenu_child">before()</a></li><li><a href="#default-cleanraws" class="sidemenu_child">cleanRaws()</a></li><li><a href="#default-clone" class="sidemenu_child">clone()</a></li><li><a href="#default-cloneafter" class="sidemenu_child">cloneAfter()</a></li><li><a href="#default-clonebefore" class="sidemenu_child">cloneBefore()</a></li><li><a href="#default-each" class="sidemenu_child">each()</a></li><li><a href="#default-error" class="sidemenu_child">error()</a></li><li><a href="#default-every" class="sidemenu_child">every()</a></li><li><a href="#default-index" class="sidemenu_child">index()</a></li><li><a href="#default-insertafter" class="sidemenu_child">insertAfter()</a></li><li><a href="#default-insertbefore" class="sidemenu_child">insertBefore()</a></li><li><a href="#default-next" class="sidemenu_child">next()</a></li><li><a href="#default-positioninside" class="sidemenu_child">positionInside()</a></li><li><a href="#default-prepend" class="sidemenu_child">prepend()</a></li><li><a href="#default-prev" class="sidemenu_child">prev()</a></li><li><a href="#default-push" class="sidemenu_child">push()</a></li><li><a href="#default-raw" class="sidemenu_child">raw()</a></li><li><a href="#default-remove" class="sidemenu_child">remove()</a></li><li><a href="#default-removeall" class="sidemenu_child">removeAll()</a></li><li><a href="#default-removechild" class="sidemenu_child">removeChild()</a></li><li><a href="#default-replacevalues" class="sidemenu_child">replaceValues()</a></li><li><a href="#default-replacewith" class="sidemenu_child">replaceWith()</a></li><li><a href="#default-root" class="sidemenu_child">root()</a></li><li><a href="#default-some" class="sidemenu_child">some()</a></li><li><a href="#default-tojson" class="sidemenu_child">toJSON()</a></li><li><a href="#default-tostring" class="sidemenu_child">toString()</a></li><li><a href="#default-walk" class="sidemenu_child">walk()</a></li><li><a href="#default-walkatrules" class="sidemenu_child">walkAtRules()</a></li><li><a href="#default-walkcomments" class="sidemenu_child">walkComments()</a></li><li><a href="#default-walkdecls" class="sidemenu_child">walkDecls()</a></li><li><a href="#default-walkrules" class="sidemenu_child">walkRules()</a></li><li><a href="#default-warn" class="sidemenu_child">warn()</a></li></ul></li><li><a href="#default" class="sidemenu_section">default</a><ul><li><a href="#default-column" class="sidemenu_child">column</a></li><li><a href="#default-file" class="sidemenu_child">file</a></li><li><a href="#default-input" class="sidemenu_child">input</a></li><li><a href="#default-line" class="sidemenu_child">line</a></li><li><a href="#default-message" class="sidemenu_child">message</a></li><li><a href="#default-name" class="sidemenu_child">name</a></li><li><a href="#default-plugin" class="sidemenu_child">plugin</a></li><li><a href="#default-reason" class="sidemenu_child">reason</a></li><li><a href="#default-source" class="sidemenu_child">source</a></li><li><a href="#default-showsourcecode" class="sidemenu_child">showSourceCode()</a></li><li><a href="#default-tostring" class="sidemenu_child">toString()</a></li></ul></li><li><a href="#default" class="sidemenu_section">default</a><ul><li><a href="#default-important" class="sidemenu_child">important</a></li><li><a href="#default-parent" class="sidemenu_child">parent</a></li><li><a href="#default-prop" class="sidemenu_child">prop</a></li><li><a href="#default-raws" class="sidemenu_child">raws</a></li><li><a href="#default-source" class="sidemenu_child">source</a></li><li><a href="#default-type" class="sidemenu_child">type</a></li><li><a href="#default-value" class="sidemenu_child">value</a></li><li><a href="#default-variable" class="sidemenu_child">variable</a></li><li><a href="#default-after" class="sidemenu_child">after()</a></li><li><a href="#default-before" class="sidemenu_child">before()</a></li><li><a href="#default-cleanraws" class="sidemenu_child">cleanRaws()</a></li><li><a href="#default-clone" class="sidemenu_child">clone()</a></li><li><a href="#default-cloneafter" class="sidemenu_child">cloneAfter()</a></li><li><a href="#default-clonebefore" class="sidemenu_child">cloneBefore()</a></li><li><a href="#default-error" class="sidemenu_child">error()</a></li><li><a href="#default-next" class="sidemenu_child">next()</a></li><li><a href="#default-positioninside" class="sidemenu_child">positionInside()</a></li><li><a href="#default-prev" class="sidemenu_child">prev()</a></li><li><a href="#default-raw" class="sidemenu_child">raw()</a></li><li><a href="#default-remove" class="sidemenu_child">remove()</a></li><li><a href="#default-replacewith" class="sidemenu_child">replaceWith()</a></li><li><a href="#default-root" class="sidemenu_child">root()</a></li><li><a href="#default-tojson" class="sidemenu_child">toJSON()</a></li><li><a href="#default-tostring" class="sidemenu_child">toString()</a></li><li><a href="#default-warn" class="sidemenu_child">warn()</a></li></ul></li><li><a href="#default" class="sidemenu_section">default</a><ul><li><a href="#default-css" class="sidemenu_child">css</a></li><li><a href="#default-file" class="sidemenu_child">file</a></li><li><a href="#default-hasbom" class="sidemenu_child">hasBOM</a></li><li><a href="#default-id" class="sidemenu_child">id</a></li><li><a href="#default-map" class="sidemenu_child">map</a></li><li><a href="#default-from" class="sidemenu_child">from</a></li><li><a href="#default-fromoffset" class="sidemenu_child">fromOffset()</a></li><li><a href="#default-origin" class="sidemenu_child">origin()</a></li></ul></li><li><a href="#default" class="sidemenu_section">default</a><ul><li><a href="#default-catch" class="sidemenu_child">catch</a></li><li><a href="#default-finally" class="sidemenu_child">finally</a></li><li><a href="#default-then" class="sidemenu_child">then</a></li><li><a href="#default-[symbol.tostringtag]" class="sidemenu_child">[Symbol.toStringTag]</a></li><li><a href="#default-content" class="sidemenu_child">content</a></li><li><a href="#default-css" class="sidemenu_child">css</a></li><li><a href="#default-map" class="sidemenu_child">map</a></li><li><a href="#default-messages" class="sidemenu_child">messages</a></li><li><a href="#default-opts" class="sidemenu_child">opts</a></li><li><a href="#default-processor" class="sidemenu_child">processor</a></li><li><a href="#default-root" class="sidemenu_child">root</a></li><li><a href="#default-async" class="sidemenu_child">async()</a></li><li><a href="#default-sync" class="sidemenu_child">sync()</a></li><li><a href="#default-tostring" class="sidemenu_child">toString()</a></li><li><a href="#default-warnings" class="sidemenu_child">warnings()</a></li></ul></li><li><a href="#default" class="sidemenu_section">default</a><ul><li><a href="#default-parent" class="sidemenu_child">parent</a></li><li><a href="#default-raws" class="sidemenu_child">raws</a></li><li><a href="#default-source" class="sidemenu_child">source</a></li><li><a href="#default-type" class="sidemenu_child">type</a></li><li><a href="#default-after" class="sidemenu_child">after()</a></li><li><a href="#default-before" class="sidemenu_child">before()</a></li><li><a href="#default-cleanraws" class="sidemenu_child">cleanRaws()</a></li><li><a href="#default-clone" class="sidemenu_child">clone()</a></li><li><a href="#default-cloneafter" class="sidemenu_child">cloneAfter()</a></li><li><a href="#default-clonebefore" class="sidemenu_child">cloneBefore()</a></li><li><a href="#default-error" class="sidemenu_child">error()</a></li><li><a href="#default-next" class="sidemenu_child">next()</a></li><li><a href="#default-positioninside" class="sidemenu_child">positionInside()</a></li><li><a href="#default-prev" class="sidemenu_child">prev()</a></li><li><a href="#default-raw" class="sidemenu_child">raw()</a></li><li><a href="#default-remove" class="sidemenu_child">remove()</a></li><li><a href="#default-replacewith" class="sidemenu_child">replaceWith()</a></li><li><a href="#default-root" class="sidemenu_child">root()</a></li><li><a href="#default-tojson" class="sidemenu_child">toJSON()</a></li><li><a href="#default-tostring" class="sidemenu_child">toString()</a></li><li><a href="#default-warn" class="sidemenu_child">warn()</a></li></ul></li><li><a href="#default" class="sidemenu_section">default</a><ul><li><a href="#default-annotation" class="sidemenu_child">annotation</a></li><li><a href="#default-file" class="sidemenu_child">file</a></li><li><a href="#default-inline" class="sidemenu_child">inline</a></li><li><a href="#default-mapfile" class="sidemenu_child">mapFile</a></li><li><a href="#default-root" class="sidemenu_child">root</a></li><li><a href="#default-text" class="sidemenu_child">text</a></li><li><a href="#default-consumer" class="sidemenu_child">consumer()</a></li><li><a href="#default-withcontent" class="sidemenu_child">withContent()</a></li></ul></li><li><a href="#default" class="sidemenu_section">default</a><ul><li><a href="#default-plugins" class="sidemenu_child">plugins</a></li><li><a href="#default-version" class="sidemenu_child">version</a></li><li><a href="#default-process" class="sidemenu_child">process()</a></li><li><a href="#default-use" class="sidemenu_child">use()</a></li></ul></li><li><a href="#default" class="sidemenu_section">default</a><ul><li><a href="#default-css" class="sidemenu_child">css</a></li><li><a href="#default-lastplugin" class="sidemenu_child">lastPlugin</a></li><li><a href="#default-map" class="sidemenu_child">map</a></li><li><a href="#default-messages" class="sidemenu_child">messages</a></li><li><a href="#default-opts" class="sidemenu_child">opts</a></li><li><a href="#default-processor" class="sidemenu_child">processor</a></li><li><a href="#default-root" class="sidemenu_child">root</a></li><li><a href="#default-content" class="sidemenu_child">content</a></li><li><a href="#default-tostring" class="sidemenu_child">toString()</a></li><li><a href="#default-warn" class="sidemenu_child">warn()</a></li><li><a href="#default-warnings" class="sidemenu_child">warnings()</a></li></ul></li><li><a href="#default" class="sidemenu_section">default</a><ul><li><a href="#default-nodes" class="sidemenu_child">nodes</a></li><li><a href="#default-parent" class="sidemenu_child">parent</a></li><li><a href="#default-raws" class="sidemenu_child">raws</a></li><li><a href="#default-source" class="sidemenu_child">source</a></li><li><a href="#default-type" class="sidemenu_child">type</a></li><li><a href="#default-first" class="sidemenu_child">first</a></li><li><a href="#default-last" class="sidemenu_child">last</a></li><li><a href="#default-after" class="sidemenu_child">after()</a></li><li><a href="#default-append" class="sidemenu_child">append()</a></li><li><a href="#default-before" class="sidemenu_child">before()</a></li><li><a href="#default-cleanraws" class="sidemenu_child">cleanRaws()</a></li><li><a href="#default-clone" class="sidemenu_child">clone()</a></li><li><a href="#default-cloneafter" class="sidemenu_child">cloneAfter()</a></li><li><a href="#default-clonebefore" class="sidemenu_child">cloneBefore()</a></li><li><a href="#default-each" class="sidemenu_child">each()</a></li><li><a href="#default-error" class="sidemenu_child">error()</a></li><li><a href="#default-every" class="sidemenu_child">every()</a></li><li><a href="#default-index" class="sidemenu_child">index()</a></li><li><a href="#default-insertafter" class="sidemenu_child">insertAfter()</a></li><li><a href="#default-insertbefore" class="sidemenu_child">insertBefore()</a></li><li><a href="#default-next" class="sidemenu_child">next()</a></li><li><a href="#default-positioninside" class="sidemenu_child">positionInside()</a></li><li><a href="#default-prepend" class="sidemenu_child">prepend()</a></li><li><a href="#default-prev" class="sidemenu_child">prev()</a></li><li><a href="#default-push" class="sidemenu_child">push()</a></li><li><a href="#default-raw" class="sidemenu_child">raw()</a></li><li><a href="#default-remove" class="sidemenu_child">remove()</a></li><li><a href="#default-removeall" class="sidemenu_child">removeAll()</a></li><li><a href="#default-removechild" class="sidemenu_child">removeChild()</a></li><li><a href="#default-replacevalues" class="sidemenu_child">replaceValues()</a></li><li><a href="#default-replacewith" class="sidemenu_child">replaceWith()</a></li><li><a href="#default-root" class="sidemenu_child">root()</a></li><li><a href="#default-some" class="sidemenu_child">some()</a></li><li><a href="#default-tojson" class="sidemenu_child">toJSON()</a></li><li><a href="#default-toresult" class="sidemenu_child">toResult()</a></li><li><a href="#default-tostring" class="sidemenu_child">toString()</a></li><li><a href="#default-walk" class="sidemenu_child">walk()</a></li><li><a href="#default-walkatrules" class="sidemenu_child">walkAtRules()</a></li><li><a href="#default-walkcomments" class="sidemenu_child">walkComments()</a></li><li><a href="#default-walkdecls" class="sidemenu_child">walkDecls()</a></li><li><a href="#default-walkrules" class="sidemenu_child">walkRules()</a></li><li><a href="#default-warn" class="sidemenu_child">warn()</a></li></ul></li><li><a href="#default" class="sidemenu_section">default</a><ul><li><a href="#default-nodes" class="sidemenu_child">nodes</a></li><li><a href="#default-parent" class="sidemenu_child">parent</a></li><li><a href="#default-raws" class="sidemenu_child">raws</a></li><li><a href="#default-selector" class="sidemenu_child">selector</a></li><li><a href="#default-selectors" class="sidemenu_child">selectors</a></li><li><a href="#default-source" class="sidemenu_child">source</a></li><li><a href="#default-type" class="sidemenu_child">type</a></li><li><a href="#default-first" class="sidemenu_child">first</a></li><li><a href="#default-last" class="sidemenu_child">last</a></li><li><a href="#default-after" class="sidemenu_child">after()</a></li><li><a href="#default-append" class="sidemenu_child">append()</a></li><li><a href="#default-before" class="sidemenu_child">before()</a></li><li><a href="#default-cleanraws" class="sidemenu_child">cleanRaws()</a></li><li><a href="#default-clone" class="sidemenu_child">clone()</a></li><li><a href="#default-cloneafter" class="sidemenu_child">cloneAfter()</a></li><li><a href="#default-clonebefore" class="sidemenu_child">cloneBefore()</a></li><li><a href="#default-each" class="sidemenu_child">each()</a></li><li><a href="#default-error" class="sidemenu_child">error()</a></li><li><a href="#default-every" class="sidemenu_child">every()</a></li><li><a href="#default-index" class="sidemenu_child">index()</a></li><li><a href="#default-insertafter" class="sidemenu_child">insertAfter()</a></li><li><a href="#default-insertbefore" class="sidemenu_child">insertBefore()</a></li><li><a href="#default-next" class="sidemenu_child">next()</a></li><li><a href="#default-positioninside" class="sidemenu_child">positionInside()</a></li><li><a href="#default-prepend" class="sidemenu_child">prepend()</a></li><li><a href="#default-prev" class="sidemenu_child">prev()</a></li><li><a href="#default-push" class="sidemenu_child">push()</a></li><li><a href="#default-raw" class="sidemenu_child">raw()</a></li><li><a href="#default-remove" class="sidemenu_child">remove()</a></li><li><a href="#default-removeall" class="sidemenu_child">removeAll()</a></li><li><a href="#default-removechild" class="sidemenu_child">removeChild()</a></li><li><a href="#default-replacevalues" class="sidemenu_child">replaceValues()</a></li><li><a href="#default-replacewith" class="sidemenu_child">replaceWith()</a></li><li><a href="#default-root" class="sidemenu_child">root()</a></li><li><a href="#default-some" class="sidemenu_child">some()</a></li><li><a href="#default-tojson" class="sidemenu_child">toJSON()</a></li><li><a href="#default-tostring" class="sidemenu_child">toString()</a></li><li><a href="#default-walk" class="sidemenu_child">walk()</a></li><li><a href="#default-walkatrules" class="sidemenu_child">walkAtRules()</a></li><li><a href="#default-walkcomments" class="sidemenu_child">walkComments()</a></li><li><a href="#default-walkdecls" class="sidemenu_child">walkDecls()</a></li><li><a href="#default-walkrules" class="sidemenu_child">walkRules()</a></li><li><a href="#default-warn" class="sidemenu_child">warn()</a></li></ul></li><li><a href="#default" class="sidemenu_section">default</a><ul><li><a href="#default-column" class="sidemenu_child">column</a></li><li><a href="#default-line" class="sidemenu_child">line</a></li><li><a href="#default-node" class="sidemenu_child">node</a></li><li><a href="#default-plugin" class="sidemenu_child">plugin</a></li><li><a href="#default-text" class="sidemenu_child">text</a></li><li><a href="#default-type" class="sidemenu_child">type</a></li><li><a href="#default-tostring" class="sidemenu_child">toString()</a></li></ul></li></ul></nav><main><section class="doc"><h1 id="default" class="doc_title">default</h1><p>Represents an at-rule.</p>
<pre><code class="code">Once (root, { AtRule }) {
  <span class="code_keyword">let</span> media = <span class="code_keyword">new</span> AtRule({ <span class="code_attr">name</span>: <span class="code_string">'media'</span>, <span class="code_attr">params</span>: <span class="code_string">'print'</span> })
  media.append(…)
  root.append(media)
}</code></pre>
<p>If it’s followed in the CSS by a {} block, this node will have
a nodes property representing its children.</p>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(<span class="code_string">'@charset "UTF-8"; @media print {}'</span>)

<span class="code_keyword">const</span> charset = root.first
charset.type  <span class="code_comment">//=> 'atrule'</span>
charset.nodes <span class="code_comment">//=> undefined</span>

<span class="code_keyword">const</span> media = root.last
media.nodes   <span class="code_comment">//=> []</span></code></pre>
<h2 id="default-name" class="doc_subtitle"><span class="doc_prefix">default#</span>name</h2><p>The at-rule’s name immediately follows the <code>@</code>.</p>
<pre><code class="code"><span class="code_keyword">const</span> root  = postcss.parse(<span class="code_string">'@media print {}'</span>)
media.name <span class="code_comment">//=> 'media'</span>
<span class="code_keyword">const</span> media = root.first</code></pre>
<p>Type: string.</p><h2 id="default-nodes" class="doc_subtitle"><span class="doc_prefix">default#</span>nodes</h2><p>An array containing the container’s children.</p>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(<span class="code_string">'a { color: black }'</span>)
root.nodes.length           <span class="code_comment">//=> 1</span>
root.nodes[<span class="code_number">0</span>].selector      <span class="code_comment">//=> 'a'</span>
root.nodes[<span class="code_number">0</span>].nodes[<span class="code_number">0</span>].prop <span class="code_comment">//=> 'color'</span></code></pre>
<p>Type: <a href="#childnode">ChildNode</a>[].</p><h2 id="default-params" class="doc_subtitle"><span class="doc_prefix">default#</span>params</h2><p>The at-rule’s parameters, the values that follow the at-rule’s name
but precede any {} block.</p>
<pre><code class="code"><span class="code_keyword">const</span> root  = postcss.parse(<span class="code_string">'@media print, screen {}'</span>)
<span class="code_keyword">const</span> media = root.first
media.params <span class="code_comment">//=> 'print, screen'</span></code></pre>
<p>Type: string.</p><h2 id="default-parent" class="doc_subtitle"><span class="doc_prefix">default#</span>parent</h2><p>The node’s parent node.</p>
<pre><code class="code">root.nodes[<span class="code_number">0</span>].parent === root</code></pre>
<p>Type: default.</p><h2 id="default-raws" class="doc_subtitle"><span class="doc_prefix">default#</span>raws</h2><p>Information to generate byte-to-byte equal node string as it was
in the origin input.</p>
<p>Every parser saves its own properties,
but the default CSS parser uses:</p>
<ul>
<li><code>before</code>: the space symbols before the node. It also stores <code>*</code>
and <code>_</code> symbols before the declaration (IE hack).</li>
<li><code>after</code>: the space symbols after the last child of the node
to the end of the node.</li>
<li><code>between</code>: the symbols between the property and value
for declarations, selector and <code>{</code> for rules, or last parameter
and <code>{</code> for at-rules.</li>
<li><code>semicolon</code>: contains true if the last child has
an (optional) semicolon.</li>
<li><code>afterName</code>: the space between the at-rule name and its parameters.</li>
<li><code>left</code>: the space symbols between <code>/*</code> and the comment’s text.</li>
<li><code>right</code>: the space symbols between the comment’s text
and <code>*/</code>.</li>
<li><code>important</code>: the content of the important statement,
if it is not just <code>!important</code>.</li>
</ul>
<p>PostCSS cleans selectors, declaration values and at-rule parameters
from comments and extra spaces, but it stores origin content in raws
properties. As such, if you don’t change a declaration’s value,
PostCSS will use the raw value with comments.</p>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(<span class="code_string">'a {\n  color:black\n}'</span>)
root.first.first.raws <span class="code_comment">//=> { before: '\n  ', between: ':' }</span></code></pre>
<p>Type: <a href="#atruleraws">AtRuleRaws</a>.</p><h2 id="default-source" class="doc_subtitle"><span class="doc_prefix">default#</span>source</h2><p>The input source of the node.</p>
<p>The property is used in source map generation.</p>
<p>If you create a node manually (e.g., with <code>postcss.decl()</code>),
that node will not have a <code>source</code> property and will be absent
from the source map. For this reason, the plugin developer should
consider cloning nodes to create new ones (in which case the new node’s
source will reference the original, cloned node) or setting
the <code>source</code> property manually.</p>
<pre><code class="code">decl.source.input.from <span class="code_comment">//=> '/home/ai/a.sass'</span>
decl.source.start      <span class="code_comment">//=> { line: 10, column: 2 }</span>
decl.source.end        <span class="code_comment">//=> { line: 10, column: 12 }</span></code></pre>
<pre><code class="code"><span class="code_comment">// Bad</span>
<span class="code_keyword">const</span> prefixed = postcss.decl({
  <span class="code_attr">prop</span>: <span class="code_string">'-moz-'</span> + decl.prop,
  <span class="code_attr">value</span>: decl.value
})

<span class="code_comment">// Good</span>
<span class="code_keyword">const</span> prefixed = decl.clone({ <span class="code_attr">prop</span>: <span class="code_string">'-moz-'</span> + decl.prop })</code></pre>
<pre><code class="code"><span class="code_keyword">if</span> (atrule.name === <span class="code_string">'add-link'</span>) {
  <span class="code_keyword">const</span> rule = postcss.rule({ <span class="code_attr">selector</span>: <span class="code_string">'a'</span>, <span class="code_attr">source</span>: atrule.source })
  atrule.parent.insertBefore(atrule, rule)
}</code></pre>
<p>Type: <a href="#source">Source</a>.</p><h2 id="default-type" class="doc_subtitle"><span class="doc_prefix">default#</span>type</h2><p>tring representing the node’s type. Possible values are <code>root</code>, <code>atrule</code>,
<code>rule</code>, <code>decl</code>, or <code>comment</code>.</p>
<pre><code class="code"><span class="code_keyword">new</span> Declaration({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> }).type <span class="code_comment">//=> 'decl'</span></code></pre>
<p>Type: "atrule".</p><h2 id="default-first" class="doc_subtitle"><span class="doc_prefix">default#</span>first</h2><p>The container’s first child.</p>
<pre><code class="code">rule.first === rules.nodes[<span class="code_number">0</span>]</code></pre>
<h2 id="default-last" class="doc_subtitle"><span class="doc_prefix">default#</span>last</h2><p>The container’s last child.</p>
<pre><code class="code">rule.last === rule.nodes[rule.nodes.length - <span class="code_number">1</span>]</code></pre>
<h2 id="default-after" class="doc_subtitle"><span class="doc_prefix">default#</span>after()</h2><p>Insert new node after current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertAfter(node, add)</code>.</p>
<pre><code class="code">decl.after(<span class="code_string">'color: black'</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#atruleprops">AtRuleProps</a> | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | default | default[]</td><td>New node.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-append" class="doc_subtitle"><span class="doc_prefix">default#</span>append()</h2><p>Inserts new nodes to the end of the container.</p>
<pre><code class="code"><span class="code_keyword">const</span> decl1 = <span class="code_keyword">new</span> Declaration({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> })
<span class="code_keyword">const</span> decl2 = <span class="code_keyword">new</span> Declaration({ <span class="code_attr">prop</span>: <span class="code_string">'background-color'</span>, <span class="code_attr">value</span>: <span class="code_string">'white'</span> })
rule.append(decl1, decl2)

root.append({ <span class="code_attr">name</span>: <span class="code_string">'charset'</span>, <span class="code_attr">params</span>: <span class="code_string">'"UTF-8"'</span> })  <span class="code_comment">// at-rule</span>
root.append({ <span class="code_attr">selector</span>: <span class="code_string">'a'</span> })                       <span class="code_comment">// rule</span>
rule.append({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> })       <span class="code_comment">// declaration</span>
rule.append({ <span class="code_attr">text</span>: <span class="code_string">'Comment'</span> })                     <span class="code_comment">// comment</span>

root.append(<span class="code_string">'a {}'</span>)
root.first.append(<span class="code_string">'color: black; z-index: 1'</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td>(string | <a href="#atruleprops">AtRuleProps</a> | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | default | default[] | <a href="#childprops">ChildProps</a>[] | string[])[]</td><td>New nodes.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-before" class="doc_subtitle"><span class="doc_prefix">default#</span>before()</h2><p>Insert new node before current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertBefore(node, add)</code>.</p>
<pre><code class="code">decl.before(<span class="code_string">'content: ""'</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#atruleprops">AtRuleProps</a> | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | default | default[]</td><td>New node.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-cleanraws" class="doc_subtitle"><span class="doc_prefix">default#</span>cleanRaws()</h2><p>Clear the code style properties for the node and its children.</p>
<pre><code class="code">node.raws.before  <span class="code_comment">//=> ' '</span>
node.cleanRaws()
node.raws.before  <span class="code_comment">//=> undefined</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>keepBetween</code></td><td>boolean</td><td>Keep the <code>raws.between</code> symbols.
</td></tr></table><h2 id="default-clone" class="doc_subtitle"><span class="doc_prefix">default#</span>clone()</h2><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#atruleprops">AtRuleProps</a>></td><td>New properties to override in the clone.
</td></tr></table><p>Returns <code>default</code>. </p><h2 id="default-cloneafter" class="doc_subtitle"><span class="doc_prefix">default#</span>cloneAfter()</h2><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#atruleprops">AtRuleProps</a>></td><td>New properties to override in the clone.
</td></tr></table><p>Returns <code>default</code>. </p><h2 id="default-clonebefore" class="doc_subtitle"><span class="doc_prefix">default#</span>cloneBefore()</h2><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#atruleprops">AtRuleProps</a>></td><td>Mew properties to override in the clone.
</td></tr></table><p>Returns <code>default</code>. </p><h2 id="default-each" class="doc_subtitle"><span class="doc_prefix">default#</span>each()</h2><p>Iterates through the container’s immediate children,
calling <code>callback</code> for each child.</p>
<p>Returning <code>false</code> in the callback will break iteration.</p>
<p>This method only iterates through the container’s immediate children.
If you need to recursively iterate through all the container’s descendant
nodes, use <code><a href="#container-walk">Container#walk</a></code>.</p>
<p>Unlike the for <code>{}</code>-cycle or <code>Array#forEach</code> this iterator is safe
if you are mutating the array of child nodes during iteration.
PostCSS will adjust the current index to match the mutations.</p>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(<span class="code_string">'a { color: black; z-index: 1 }'</span>)
<span class="code_keyword">const</span> rule = root.first

<span class="code_keyword">for</span> (<span class="code_keyword">const</span> decl <span class="code_keyword">of</span> rule.nodes) {
  decl.cloneBefore({ <span class="code_attr">prop</span>: <span class="code_string">'-webkit-'</span> + decl.prop })
  <span class="code_comment">// Cycle will be infinite, because cloneBefore moves the current node</span>
  <span class="code_comment">// to the next index</span>
}

rule.each(<span class="code_function"><span class="code_params">decl</span> =></span> {
  decl.cloneBefore({ <span class="code_attr">prop</span>: <span class="code_string">'-webkit-'</span> + decl.prop })
  <span class="code_comment">// Will be executed only for color and z-index</span>
})</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>callback</code></td><td>(node: <a href="#childnode">ChildNode</a>, index: number) => false | void</td><td>Iterator receives each node and index.
</td></tr></table><p>Returns <code>void | false</code>. Returns <code>false</code> if iteration was broke.
</p><h2 id="default-error" class="doc_subtitle"><span class="doc_prefix">default#</span>error()</h2><p>Returns a <code><a href="#csssyntaxerror">CssSyntaxError</a></code> instance containing the original position
of the node in the source, showing line and column numbers and also
a small excerpt to facilitate debugging.</p>
<p>If present, an input source map will be used to get the original position
of the source, even from a previous compilation step
(e.g., from Sass compilation).</p>
<p>This method produces very useful error messages.</p>
<pre><code class="code"><span class="code_keyword">if</span> (!variables[name]) {
  <span class="code_keyword">throw</span> decl.error(<span class="code_string">`Unknown variable <span class="code_subst">${name}</span>`</span>, { <span class="code_attr">word</span>: name })
  <span class="code_comment">// CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black</span>
  <span class="code_comment">//   color: $black</span>
  <span class="code_comment">// a</span>
  <span class="code_comment">//          ^</span>
  <span class="code_comment">//   background: white</span>
}</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>message</code></td><td>string</td><td>Error description.
</td></tr><tr><td><code>options</code></td><td><a href="#nodeerroroptions">NodeErrorOptions</a></td><td></td></tr></table><p>Returns <code>default</code>. Error object to throw it.
</p><h2 id="default-every" class="doc_subtitle"><span class="doc_prefix">default#</span>every()</h2><p>Returns <code>true</code> if callback returns <code>true</code>
for all of the container’s children.</p>
<pre><code class="code"><span class="code_keyword">const</span> noPrefixes = rule.every(<span class="code_function"><span class="code_params">i</span> =></span> i.prop[<span class="code_number">0</span>] !== <span class="code_string">'-'</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>condition</code></td><td>(node: <a href="#childnode">ChildNode</a>, index: number, nodes: <a href="#childnode">ChildNode</a>[]) => boolean</td><td>Iterator returns true or false.
</td></tr></table><p>Returns <code>boolean</code>. Is every child pass condition.
</p><h2 id="default-index" class="doc_subtitle"><span class="doc_prefix">default#</span>index()</h2><p>Returns a <code>child</code>’s index within the <code><a href="#container-nodes">Container#nodes</a></code> array.</p>
<pre><code class="code">rule.index( rule.nodes[<span class="code_number">2</span>] ) <span class="code_comment">//=> 2</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td>number | default | default | default | default</td><td>Child of the current container.
</td></tr></table><p>Returns <code>number</code>. Child index.
</p><h2 id="default-insertafter" class="doc_subtitle"><span class="doc_prefix">default#</span>insertAfter()</h2><p>Insert new node after old node within the container.</p>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>oldNode</code></td><td>number | default | default | default | default</td><td>Child or child’s index.
</td></tr><tr><td><code>newNode</code></td><td>string | <a href="#atruleprops">AtRuleProps</a> | default | default | default | default | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | <a href="#childnode">ChildNode</a>[] | <a href="#childprops">ChildProps</a>[] | string[]</td><td>New node.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-insertbefore" class="doc_subtitle"><span class="doc_prefix">default#</span>insertBefore()</h2><p>Insert new node before old node within the container.</p>
<pre><code class="code">rule.insertBefore(decl, decl.clone({ <span class="code_attr">prop</span>: <span class="code_string">'-webkit-'</span> + decl.prop }))</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>oldNode</code></td><td>number | default | default | default | default</td><td>Child or child’s index.
</td></tr><tr><td><code>newNode</code></td><td>string | <a href="#atruleprops">AtRuleProps</a> | default | default | default | default | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | <a href="#childnode">ChildNode</a>[] | <a href="#childprops">ChildProps</a>[] | string[]</td><td>New node.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-next" class="doc_subtitle"><span class="doc_prefix">default#</span>next()</h2><p>Returns the next child of the node’s parent.
Returns <code>undefined</code> if the current node is the last child.</p>
<pre><code class="code"><span class="code_keyword">if</span> (comment.text === <span class="code_string">'delete next'</span>) {
  <span class="code_keyword">const</span> next = comment.next()
  <span class="code_keyword">if</span> (next) {
    next.remove()
  }
}</code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code><a href="#childnode">ChildNode</a></code>. Next node.
</p><h2 id="default-positioninside" class="doc_subtitle"><span class="doc_prefix">default#</span>positionInside()</h2><p>Convert string index to line/column.</p>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>number</td><td>The symbol number in the node’s string.
</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. Symbol position in file.
</p><h2 id="default-prepend" class="doc_subtitle"><span class="doc_prefix">default#</span>prepend()</h2><p>Inserts new nodes to the start of the container.</p>
<pre><code class="code"><span class="code_keyword">const</span> decl1 = <span class="code_keyword">new</span> Declaration({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> })
<span class="code_keyword">const</span> decl2 = <span class="code_keyword">new</span> Declaration({ <span class="code_attr">prop</span>: <span class="code_string">'background-color'</span>, <span class="code_attr">value</span>: <span class="code_string">'white'</span> })
rule.prepend(decl1, decl2)

root.append({ <span class="code_attr">name</span>: <span class="code_string">'charset'</span>, <span class="code_attr">params</span>: <span class="code_string">'"UTF-8"'</span> })  <span class="code_comment">// at-rule</span>
root.append({ <span class="code_attr">selector</span>: <span class="code_string">'a'</span> })                       <span class="code_comment">// rule</span>
rule.append({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> })       <span class="code_comment">// declaration</span>
rule.append({ <span class="code_attr">text</span>: <span class="code_string">'Comment'</span> })                     <span class="code_comment">// comment</span>

root.append(<span class="code_string">'a {}'</span>)
root.first.append(<span class="code_string">'color: black; z-index: 1'</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td>(string | <a href="#atruleprops">AtRuleProps</a> | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | default | default[] | <a href="#childprops">ChildProps</a>[] | string[])[]</td><td>New nodes.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-prev" class="doc_subtitle"><span class="doc_prefix">default#</span>prev()</h2><p>Returns the previous child of the node’s parent.
Returns <code>undefined</code> if the current node is the first child.</p>
<pre><code class="code"><span class="code_keyword">const</span> annotation = decl.prev()
<span class="code_keyword">if</span> (annotation.type === <span class="code_string">'comment'</span>) {
  readAnnotation(annotation.text)
}</code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code><a href="#childnode">ChildNode</a></code>. Previous node.
</p><h2 id="default-push" class="doc_subtitle"><span class="doc_prefix">default#</span>push()</h2><p>Add child to the end of the node.</p>
<pre><code class="code">rule.push(<span class="code_keyword">new</span> Declaration({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> }))</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td><a href="#childnode">ChildNode</a></td><td>New node.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-raw" class="doc_subtitle"><span class="doc_prefix">default#</span>raw()</h2><p>Returns a <code><a href="#node-raws">Node#raws</a></code> value. If the node is missing
the code style property (because the node was manually built or cloned),
PostCSS will try to autodetect the code style property by looking
at other nodes in the tree.</p>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(<span class="code_string">'a { background: white }'</span>)
root.nodes[<span class="code_number">0</span>].append({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> })
root.nodes[<span class="code_number">0</span>].nodes[<span class="code_number">1</span>].raws.before   <span class="code_comment">//=> undefined</span>
root.nodes[<span class="code_number">0</span>].nodes[<span class="code_number">1</span>].raw(<span class="code_string">'before'</span>) <span class="code_comment">//=> ' '</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>prop</code></td><td>string</td><td>Name of code style property.
</td></tr><tr><td><code>defaultType</code></td><td>string</td><td>Name of default value, it can be missed
if the value is the same as prop.
</td></tr></table><p>Returns <code>string</code>. Code style value.
</p><h2 id="default-remove" class="doc_subtitle"><span class="doc_prefix">default#</span>remove()</h2><p>Removes the node from its parent and cleans the parent properties
from the node and its children.</p>
<pre><code class="code"><span class="code_keyword">if</span> (decl.prop.match(<span class="code_regexp">/^-webkit-/</span>)) {
  decl.remove()
}</code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>default</code>. Node to make calls chain.
</p><h2 id="default-removeall" class="doc_subtitle"><span class="doc_prefix">default#</span>removeAll()</h2><p>Removes all children from the container
and cleans their parent properties.</p>
<pre><code class="code">rule.removeAll()
rule.nodes.length <span class="code_comment">//=> 0</span></code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-removechild" class="doc_subtitle"><span class="doc_prefix">default#</span>removeChild()</h2><p>Removes node from the container and cleans the parent properties
from the node and its children.</p>
<pre><code class="code">rule.nodes.length  <span class="code_comment">//=> 5</span>
rule.removeChild(decl)
rule.nodes.length  <span class="code_comment">//=> 4</span>
decl.parent        <span class="code_comment">//=> undefined</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td>number | default | default | default | default</td><td>Child or child’s index.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-replacevalues" class="doc_subtitle"><span class="doc_prefix">default#</span>replaceValues()</h2><p>Passes all declaration values within the container that match pattern
through callback, replacing those values with the returned result
of callback.</p>
<p>This method is useful if you are using a custom unit or function
and need to iterate through all values.</p>
<pre><code class="code">root.replaceValues(<span class="code_regexp">/\d+rem/</span>, { <span class="code_attr">fast</span>: <span class="code_string">'rem'</span> }, <span class="code_function"><span class="code_params">string</span> =></span> {
  <span class="code_keyword">return</span> <span class="code_number">15</span> * <span class="code_built_in">parseInt</span>(string) + <span class="code_string">'px'</span>
})</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>pattern</code></td><td>string | RegExp</td><td>Replace pattern.
</td></tr><tr><td><code>options</code></td><td><a href="#valueoptions">ValueOptions</a></td><td></td></tr><tr><td><code>replaced</code></td><td>string | (substring: string, args: any[]) => string</td><td></td></tr></table><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>pattern</code></td><td>string | RegExp</td><td>Replace pattern.
</td></tr><tr><td><code>replaced</code></td><td>string | (substring: string, args: any[]) => string</td><td></td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-replacewith" class="doc_subtitle"><span class="doc_prefix">default#</span>replaceWith()</h2><p>Inserts node(s) before the current node and removes the current node.</p>
<pre><code class="code">AtRule: {
  <span class="code_attr">mixin</span>: <span class="code_function"><span class="code_params">atrule</span> =></span> {
    atrule.replaceWith(mixinRules[atrule.params])
  }
}</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td>(<a href="#atruleprops">AtRuleProps</a> | default | default | default | default | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | <a href="#childnode">ChildNode</a>[] | <a href="#childprops">ChildProps</a>[])[]</td><td>Mode(s) to replace current one.
</td></tr></table><p>Returns <code>default</code>. Current node to methods chain.
</p><h2 id="default-root" class="doc_subtitle"><span class="doc_prefix">default#</span>root()</h2><p>Finds the Root instance of the node’s tree.</p>
<pre><code class="code">root.nodes[<span class="code_number">0</span>].nodes[<span class="code_number">0</span>].root() === root</code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>default</code>. Root parent.
</p><h2 id="default-some" class="doc_subtitle"><span class="doc_prefix">default#</span>some()</h2><p>Returns <code>true</code> if callback returns <code>true</code> for (at least) one
of the container’s children.</p>
<pre><code class="code"><span class="code_keyword">const</span> hasPrefix = rule.some(<span class="code_function"><span class="code_params">i</span> =></span> i.prop[<span class="code_number">0</span>] === <span class="code_string">'-'</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>condition</code></td><td>(node: <a href="#childnode">ChildNode</a>, index: number, nodes: <a href="#childnode">ChildNode</a>[]) => boolean</td><td>Iterator returns true or false.
</td></tr></table><p>Returns <code>boolean</code>. Is some child pass condition.
</p><h2 id="default-tojson" class="doc_subtitle"><span class="doc_prefix">default#</span>toJSON()</h2><p>Fix circular links on <code>JSON.stringify()</code>.</p>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>object</code>. Cleaned object.
</p><h2 id="default-tostring" class="doc_subtitle"><span class="doc_prefix">default#</span>toString()</h2><p>Returns a CSS string representing the node.</p>
<pre><code class="code"><span class="code_keyword">new</span> Rule({ <span class="code_attr">selector</span>: <span class="code_string">'a'</span> }).toString() <span class="code_comment">//=> "a {}"</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>stringifier</code></td><td><a href="#stringifier">Stringifier</a> | <a href="#syntax">Syntax</a></td><td>A syntax to use in string generation.
</td></tr></table><p>Returns <code>string</code>. CSS string of this node.
</p><h2 id="default-walk" class="doc_subtitle"><span class="doc_prefix">default#</span>walk()</h2><p>Traverses the container’s descendant nodes, calling callback
for each node.</p>
<p>Like container.each(), this method is safe to use
if you are mutating arrays during iteration.</p>
<p>If you only need to iterate through the container’s immediate children,
use <code><a href="#container-each">Container#each</a></code>.</p>
<pre><code class="code">root.walk(<span class="code_function"><span class="code_params">node</span> =></span> {
  <span class="code_comment">// Traverses all descendant nodes.</span>
})</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>callback</code></td><td>(node: <a href="#childnode">ChildNode</a>, index: number) => false | void</td><td>Iterator receives each node and index.
</td></tr></table><p>Returns <code>void | false</code>. Returns <code>false</code> if iteration was broke.
</p><h2 id="default-walkatrules" class="doc_subtitle"><span class="doc_prefix">default#</span>walkAtRules()</h2><p>Traverses the container’s descendant nodes, calling callback
for each at-rule node.</p>
<p>If you pass a filter, iteration will only happen over at-rules
that have matching names.</p>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<pre><code class="code">root.walkAtRules(<span class="code_function"><span class="code_params">rule</span> =></span> {
  <span class="code_keyword">if</span> (isOld(rule.name)) rule.remove()
})

<span class="code_keyword">let</span> first = <span class="code_literal">false</span>
root.walkAtRules(<span class="code_string">'charset'</span>, <span class="code_function"><span class="code_params">rule</span> =></span> {
  <span class="code_keyword">if</span> (!first) {
    first = <span class="code_literal">true</span>
  } <span class="code_keyword">else</span> {
    rule.remove()
  }
})</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nameFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>(atRule: default, index: number) => false | void</td><td>Iterator receives each node and index.
</td></tr></table><p>Returns <code>void | false</code>. Returns <code>false</code> if iteration was broke.
</p><h2 id="default-walkcomments" class="doc_subtitle"><span class="doc_prefix">default#</span>walkComments()</h2><p>Traverses the container’s descendant nodes, calling callback
for each comment node.</p>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<pre><code class="code">root.walkComments(<span class="code_function"><span class="code_params">comment</span> =></span> {
  comment.remove()
})</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>callback</code></td><td>(comment: default, indexed: number) => false | void</td><td>Iterator receives each node and index.
</td></tr></table><p>Returns <code>void | false</code>. Returns <code>false</code> if iteration was broke.
</p><h2 id="default-walkdecls" class="doc_subtitle"><span class="doc_prefix">default#</span>walkDecls()</h2><p>Traverses the container’s descendant nodes, calling callback
for each declaration node.</p>
<p>If you pass a filter, iteration will only happen over declarations
with matching properties.</p>
<pre><code class="code">root.walkDecls(<span class="code_function"><span class="code_params">decl</span> =></span> {
  checkPropertySupport(decl.prop)
})

root.walkDecls(<span class="code_string">'border-radius'</span>, <span class="code_function"><span class="code_params">decl</span> =></span> {
  decl.remove()
})

root.walkDecls(<span class="code_regexp">/^background/</span>, <span class="code_function"><span class="code_params">decl</span> =></span> {
  decl.value = takeFirstColorFromGradient(decl.value)
})</code></pre>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>propFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>(decl: default, index: number) => false | void</td><td>Iterator receives each node and index.
</td></tr></table><p>Returns <code>void | false</code>. Returns <code>false</code> if iteration was broke.
</p><h2 id="default-walkrules" class="doc_subtitle"><span class="doc_prefix">default#</span>walkRules()</h2><p>Traverses the container’s descendant nodes, calling callback
for each rule node.</p>
<p>If you pass a filter, iteration will only happen over rules
with matching selectors.</p>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<pre><code class="code"><span class="code_keyword">const</span> selectors = []
root.walkRules(<span class="code_function"><span class="code_params">rule</span> =></span> {
  selectors.push(rule.selector)
})
<span class="code_built_in">console</span>.log(<span class="code_string">`Your CSS uses <span class="code_subst">${ selectors.length }</span> selectors`</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>selectorFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>(atRule: default, index: number) => false | void</td><td>Iterator receives each node and index.
</td></tr></table><p>Returns <code>void | false</code>. Returns <code>false</code> if iteration was broke.
</p><h2 id="default-warn" class="doc_subtitle"><span class="doc_prefix">default#</span>warn()</h2><p>This method is provided as a convenience wrapper for <code><a href="#result-warn">Result#warn</a></code>.</p>
<pre><code class="code">  Declaration: {
    <span class="code_attr">bad</span>: <span class="code_function">(<span class="code_params">decl, { result }</span>) =></span> {
      decl.warn(result, <span class="code_string">'Deprecated property bad'</span>)
    }
  }</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>result</code></td><td>default</td><td>The <code><a href="#result">Result</a></code> instance that will receive the warning.
</td></tr><tr><td><code>text</code></td><td>string</td><td>Warning message.
</td></tr><tr><td><code>opts</code></td><td><a href="#warningoptions">WarningOptions</a></td><td>Warning Options.
</td></tr></table></section><section class="doc"><h1 id="default" class="doc_title">default</h1><p>Represents a comment between declarations or statements (rule and at-rules).</p>
<pre><code class="code">Once (root, { Comment }) {
  <span class="code_keyword">let</span> note = <span class="code_keyword">new</span> Comment({ <span class="code_attr">text</span>: <span class="code_string">'Note: …'</span> })
  root.append(note)
}</code></pre>
<p>Comments inside selectors, at-rule parameters, or declaration values
will be stored in the <code>raws</code> properties explained above.</p>
<h2 id="default-parent" class="doc_subtitle"><span class="doc_prefix">default#</span>parent</h2><p>The node’s parent node.</p>
<pre><code class="code">root.nodes[<span class="code_number">0</span>].parent === root</code></pre>
<p>Type: default.</p><h2 id="default-raws" class="doc_subtitle"><span class="doc_prefix">default#</span>raws</h2><p>Information to generate byte-to-byte equal node string as it was
in the origin input.</p>
<p>Every parser saves its own properties,
but the default CSS parser uses:</p>
<ul>
<li><code>before</code>: the space symbols before the node. It also stores <code>*</code>
and <code>_</code> symbols before the declaration (IE hack).</li>
<li><code>after</code>: the space symbols after the last child of the node
to the end of the node.</li>
<li><code>between</code>: the symbols between the property and value
for declarations, selector and <code>{</code> for rules, or last parameter
and <code>{</code> for at-rules.</li>
<li><code>semicolon</code>: contains true if the last child has
an (optional) semicolon.</li>
<li><code>afterName</code>: the space between the at-rule name and its parameters.</li>
<li><code>left</code>: the space symbols between <code>/*</code> and the comment’s text.</li>
<li><code>right</code>: the space symbols between the comment’s text
and <code>*/</code>.</li>
<li><code>important</code>: the content of the important statement,
if it is not just <code>!important</code>.</li>
</ul>
<p>PostCSS cleans selectors, declaration values and at-rule parameters
from comments and extra spaces, but it stores origin content in raws
properties. As such, if you don’t change a declaration’s value,
PostCSS will use the raw value with comments.</p>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(<span class="code_string">'a {\n  color:black\n}'</span>)
root.first.first.raws <span class="code_comment">//=> { before: '\n  ', between: ':' }</span></code></pre>
<p>Type: <a href="#commentraws">CommentRaws</a>.</p><h2 id="default-source" class="doc_subtitle"><span class="doc_prefix">default#</span>source</h2><p>The input source of the node.</p>
<p>The property is used in source map generation.</p>
<p>If you create a node manually (e.g., with <code>postcss.decl()</code>),
that node will not have a <code>source</code> property and will be absent
from the source map. For this reason, the plugin developer should
consider cloning nodes to create new ones (in which case the new node’s
source will reference the original, cloned node) or setting
the <code>source</code> property manually.</p>
<pre><code class="code">decl.source.input.from <span class="code_comment">//=> '/home/ai/a.sass'</span>
decl.source.start      <span class="code_comment">//=> { line: 10, column: 2 }</span>
decl.source.end        <span class="code_comment">//=> { line: 10, column: 12 }</span></code></pre>
<pre><code class="code"><span class="code_comment">// Bad</span>
<span class="code_keyword">const</span> prefixed = postcss.decl({
  <span class="code_attr">prop</span>: <span class="code_string">'-moz-'</span> + decl.prop,
  <span class="code_attr">value</span>: decl.value
})

<span class="code_comment">// Good</span>
<span class="code_keyword">const</span> prefixed = decl.clone({ <span class="code_attr">prop</span>: <span class="code_string">'-moz-'</span> + decl.prop })</code></pre>
<pre><code class="code"><span class="code_keyword">if</span> (atrule.name === <span class="code_string">'add-link'</span>) {
  <span class="code_keyword">const</span> rule = postcss.rule({ <span class="code_attr">selector</span>: <span class="code_string">'a'</span>, <span class="code_attr">source</span>: atrule.source })
  atrule.parent.insertBefore(atrule, rule)
}</code></pre>
<p>Type: <a href="#source">Source</a>.</p><h2 id="default-text" class="doc_subtitle"><span class="doc_prefix">default#</span>text</h2><p>The comment's text.</p>
<p>Type: string.</p><h2 id="default-type" class="doc_subtitle"><span class="doc_prefix">default#</span>type</h2><p>tring representing the node’s type. Possible values are <code>root</code>, <code>atrule</code>,
<code>rule</code>, <code>decl</code>, or <code>comment</code>.</p>
<pre><code class="code"><span class="code_keyword">new</span> Declaration({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> }).type <span class="code_comment">//=> 'decl'</span></code></pre>
<p>Type: "comment".</p><h2 id="default-after" class="doc_subtitle"><span class="doc_prefix">default#</span>after()</h2><p>Insert new node after current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertAfter(node, add)</code>.</p>
<pre><code class="code">decl.after(<span class="code_string">'color: black'</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#atruleprops">AtRuleProps</a> | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | default | default[]</td><td>New node.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-before" class="doc_subtitle"><span class="doc_prefix">default#</span>before()</h2><p>Insert new node before current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertBefore(node, add)</code>.</p>
<pre><code class="code">decl.before(<span class="code_string">'content: ""'</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#atruleprops">AtRuleProps</a> | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | default | default[]</td><td>New node.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-cleanraws" class="doc_subtitle"><span class="doc_prefix">default#</span>cleanRaws()</h2><p>Clear the code style properties for the node and its children.</p>
<pre><code class="code">node.raws.before  <span class="code_comment">//=> ' '</span>
node.cleanRaws()
node.raws.before  <span class="code_comment">//=> undefined</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>keepBetween</code></td><td>boolean</td><td>Keep the <code>raws.between</code> symbols.
</td></tr></table><h2 id="default-clone" class="doc_subtitle"><span class="doc_prefix">default#</span>clone()</h2><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#commentprops">CommentProps</a>></td><td>New properties to override in the clone.
</td></tr></table><p>Returns <code>default</code>. </p><h2 id="default-cloneafter" class="doc_subtitle"><span class="doc_prefix">default#</span>cloneAfter()</h2><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#commentprops">CommentProps</a>></td><td>New properties to override in the clone.
</td></tr></table><p>Returns <code>default</code>. </p><h2 id="default-clonebefore" class="doc_subtitle"><span class="doc_prefix">default#</span>cloneBefore()</h2><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#commentprops">CommentProps</a>></td><td>Mew properties to override in the clone.
</td></tr></table><p>Returns <code>default</code>. </p><h2 id="default-error" class="doc_subtitle"><span class="doc_prefix">default#</span>error()</h2><p>Returns a <code><a href="#csssyntaxerror">CssSyntaxError</a></code> instance containing the original position
of the node in the source, showing line and column numbers and also
a small excerpt to facilitate debugging.</p>
<p>If present, an input source map will be used to get the original position
of the source, even from a previous compilation step
(e.g., from Sass compilation).</p>
<p>This method produces very useful error messages.</p>
<pre><code class="code"><span class="code_keyword">if</span> (!variables[name]) {
  <span class="code_keyword">throw</span> decl.error(<span class="code_string">`Unknown variable <span class="code_subst">${name}</span>`</span>, { <span class="code_attr">word</span>: name })
  <span class="code_comment">// CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black</span>
  <span class="code_comment">//   color: $black</span>
  <span class="code_comment">// a</span>
  <span class="code_comment">//          ^</span>
  <span class="code_comment">//   background: white</span>
}</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>message</code></td><td>string</td><td>Error description.
</td></tr><tr><td><code>options</code></td><td><a href="#nodeerroroptions">NodeErrorOptions</a></td><td></td></tr></table><p>Returns <code>default</code>. Error object to throw it.
</p><h2 id="default-next" class="doc_subtitle"><span class="doc_prefix">default#</span>next()</h2><p>Returns the next child of the node’s parent.
Returns <code>undefined</code> if the current node is the last child.</p>
<pre><code class="code"><span class="code_keyword">if</span> (comment.text === <span class="code_string">'delete next'</span>) {
  <span class="code_keyword">const</span> next = comment.next()
  <span class="code_keyword">if</span> (next) {
    next.remove()
  }
}</code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code><a href="#childnode">ChildNode</a></code>. Next node.
</p><h2 id="default-positioninside" class="doc_subtitle"><span class="doc_prefix">default#</span>positionInside()</h2><p>Convert string index to line/column.</p>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>number</td><td>The symbol number in the node’s string.
</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. Symbol position in file.
</p><h2 id="default-prev" class="doc_subtitle"><span class="doc_prefix">default#</span>prev()</h2><p>Returns the previous child of the node’s parent.
Returns <code>undefined</code> if the current node is the first child.</p>
<pre><code class="code"><span class="code_keyword">const</span> annotation = decl.prev()
<span class="code_keyword">if</span> (annotation.type === <span class="code_string">'comment'</span>) {
  readAnnotation(annotation.text)
}</code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code><a href="#childnode">ChildNode</a></code>. Previous node.
</p><h2 id="default-raw" class="doc_subtitle"><span class="doc_prefix">default#</span>raw()</h2><p>Returns a <code><a href="#node-raws">Node#raws</a></code> value. If the node is missing
the code style property (because the node was manually built or cloned),
PostCSS will try to autodetect the code style property by looking
at other nodes in the tree.</p>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(<span class="code_string">'a { background: white }'</span>)
root.nodes[<span class="code_number">0</span>].append({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> })
root.nodes[<span class="code_number">0</span>].nodes[<span class="code_number">1</span>].raws.before   <span class="code_comment">//=> undefined</span>
root.nodes[<span class="code_number">0</span>].nodes[<span class="code_number">1</span>].raw(<span class="code_string">'before'</span>) <span class="code_comment">//=> ' '</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>prop</code></td><td>string</td><td>Name of code style property.
</td></tr><tr><td><code>defaultType</code></td><td>string</td><td>Name of default value, it can be missed
if the value is the same as prop.
</td></tr></table><p>Returns <code>string</code>. Code style value.
</p><h2 id="default-remove" class="doc_subtitle"><span class="doc_prefix">default#</span>remove()</h2><p>Removes the node from its parent and cleans the parent properties
from the node and its children.</p>
<pre><code class="code"><span class="code_keyword">if</span> (decl.prop.match(<span class="code_regexp">/^-webkit-/</span>)) {
  decl.remove()
}</code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>default</code>. Node to make calls chain.
</p><h2 id="default-replacewith" class="doc_subtitle"><span class="doc_prefix">default#</span>replaceWith()</h2><p>Inserts node(s) before the current node and removes the current node.</p>
<pre><code class="code">AtRule: {
  <span class="code_attr">mixin</span>: <span class="code_function"><span class="code_params">atrule</span> =></span> {
    atrule.replaceWith(mixinRules[atrule.params])
  }
}</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td>(<a href="#atruleprops">AtRuleProps</a> | default | default | default | default | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | <a href="#childnode">ChildNode</a>[] | <a href="#childprops">ChildProps</a>[])[]</td><td>Mode(s) to replace current one.
</td></tr></table><p>Returns <code>default</code>. Current node to methods chain.
</p><h2 id="default-root" class="doc_subtitle"><span class="doc_prefix">default#</span>root()</h2><p>Finds the Root instance of the node’s tree.</p>
<pre><code class="code">root.nodes[<span class="code_number">0</span>].nodes[<span class="code_number">0</span>].root() === root</code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>default</code>. Root parent.
</p><h2 id="default-tojson" class="doc_subtitle"><span class="doc_prefix">default#</span>toJSON()</h2><p>Fix circular links on <code>JSON.stringify()</code>.</p>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>object</code>. Cleaned object.
</p><h2 id="default-tostring" class="doc_subtitle"><span class="doc_prefix">default#</span>toString()</h2><p>Returns a CSS string representing the node.</p>
<pre><code class="code"><span class="code_keyword">new</span> Rule({ <span class="code_attr">selector</span>: <span class="code_string">'a'</span> }).toString() <span class="code_comment">//=> "a {}"</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>stringifier</code></td><td><a href="#stringifier">Stringifier</a> | <a href="#syntax">Syntax</a></td><td>A syntax to use in string generation.
</td></tr></table><p>Returns <code>string</code>. CSS string of this node.
</p><h2 id="default-warn" class="doc_subtitle"><span class="doc_prefix">default#</span>warn()</h2><p>This method is provided as a convenience wrapper for <code><a href="#result-warn">Result#warn</a></code>.</p>
<pre><code class="code">  Declaration: {
    <span class="code_attr">bad</span>: <span class="code_function">(<span class="code_params">decl, { result }</span>) =></span> {
      decl.warn(result, <span class="code_string">'Deprecated property bad'</span>)
    }
  }</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>result</code></td><td>default</td><td>The <code><a href="#result">Result</a></code> instance that will receive the warning.
</td></tr><tr><td><code>text</code></td><td>string</td><td>Warning message.
</td></tr><tr><td><code>opts</code></td><td><a href="#warningoptions">WarningOptions</a></td><td>Warning Options.
</td></tr></table></section><section class="doc"><h1 id="default" class="doc_title">default</h1><p>The <code><a href="#root">Root</a></code>, <code><a href="#atrule">AtRule</a></code>, and <code><a href="#rule">Rule</a></code> container nodes
inherit some common methods to help work with their children.</p>
<p>Note that all containers can store any content. If you write a rule inside
a rule, PostCSS will parse it.</p>
<h2 id="default-nodes" class="doc_subtitle"><span class="doc_prefix">default#</span>nodes</h2><p>An array containing the container’s children.</p>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(<span class="code_string">'a { color: black }'</span>)
root.nodes.length           <span class="code_comment">//=> 1</span>
root.nodes[<span class="code_number">0</span>].selector      <span class="code_comment">//=> 'a'</span>
root.nodes[<span class="code_number">0</span>].nodes[<span class="code_number">0</span>].prop <span class="code_comment">//=> 'color'</span></code></pre>
<p>Type: <a href="#childnode">ChildNode</a>[].</p><h2 id="default-parent" class="doc_subtitle"><span class="doc_prefix">default#</span>parent</h2><p>The node’s parent node.</p>
<pre><code class="code">root.nodes[<span class="code_number">0</span>].parent === root</code></pre>
<p>Type: default.</p><h2 id="default-raws" class="doc_subtitle"><span class="doc_prefix">default#</span>raws</h2><p>Information to generate byte-to-byte equal node string as it was
in the origin input.</p>
<p>Every parser saves its own properties,
but the default CSS parser uses:</p>
<ul>
<li><code>before</code>: the space symbols before the node. It also stores <code>*</code>
and <code>_</code> symbols before the declaration (IE hack).</li>
<li><code>after</code>: the space symbols after the last child of the node
to the end of the node.</li>
<li><code>between</code>: the symbols between the property and value
for declarations, selector and <code>{</code> for rules, or last parameter
and <code>{</code> for at-rules.</li>
<li><code>semicolon</code>: contains true if the last child has
an (optional) semicolon.</li>
<li><code>afterName</code>: the space between the at-rule name and its parameters.</li>
<li><code>left</code>: the space symbols between <code>/*</code> and the comment’s text.</li>
<li><code>right</code>: the space symbols between the comment’s text
and <code>*/</code>.</li>
<li><code>important</code>: the content of the important statement,
if it is not just <code>!important</code>.</li>
</ul>
<p>PostCSS cleans selectors, declaration values and at-rule parameters
from comments and extra spaces, but it stores origin content in raws
properties. As such, if you don’t change a declaration’s value,
PostCSS will use the raw value with comments.</p>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(<span class="code_string">'a {\n  color:black\n}'</span>)
root.first.first.raws <span class="code_comment">//=> { before: '\n  ', between: ':' }</span></code></pre>
<p>Type: any.</p><h2 id="default-source" class="doc_subtitle"><span class="doc_prefix">default#</span>source</h2><p>The input source of the node.</p>
<p>The property is used in source map generation.</p>
<p>If you create a node manually (e.g., with <code>postcss.decl()</code>),
that node will not have a <code>source</code> property and will be absent
from the source map. For this reason, the plugin developer should
consider cloning nodes to create new ones (in which case the new node’s
source will reference the original, cloned node) or setting
the <code>source</code> property manually.</p>
<pre><code class="code">decl.source.input.from <span class="code_comment">//=> '/home/ai/a.sass'</span>
decl.source.start      <span class="code_comment">//=> { line: 10, column: 2 }</span>
decl.source.end        <span class="code_comment">//=> { line: 10, column: 12 }</span></code></pre>
<pre><code class="code"><span class="code_comment">// Bad</span>
<span class="code_keyword">const</span> prefixed = postcss.decl({
  <span class="code_attr">prop</span>: <span class="code_string">'-moz-'</span> + decl.prop,
  <span class="code_attr">value</span>: decl.value
})

<span class="code_comment">// Good</span>
<span class="code_keyword">const</span> prefixed = decl.clone({ <span class="code_attr">prop</span>: <span class="code_string">'-moz-'</span> + decl.prop })</code></pre>
<pre><code class="code"><span class="code_keyword">if</span> (atrule.name === <span class="code_string">'add-link'</span>) {
  <span class="code_keyword">const</span> rule = postcss.rule({ <span class="code_attr">selector</span>: <span class="code_string">'a'</span>, <span class="code_attr">source</span>: atrule.source })
  atrule.parent.insertBefore(atrule, rule)
}</code></pre>
<p>Type: <a href="#source">Source</a>.</p><h2 id="default-type" class="doc_subtitle"><span class="doc_prefix">default#</span>type</h2><p>tring representing the node’s type. Possible values are <code>root</code>, <code>atrule</code>,
<code>rule</code>, <code>decl</code>, or <code>comment</code>.</p>
<pre><code class="code"><span class="code_keyword">new</span> Declaration({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> }).type <span class="code_comment">//=> 'decl'</span></code></pre>
<p>Type: string.</p><h2 id="default-first" class="doc_subtitle"><span class="doc_prefix">default#</span>first</h2><p>The container’s first child.</p>
<pre><code class="code">rule.first === rules.nodes[<span class="code_number">0</span>]</code></pre>
<h2 id="default-last" class="doc_subtitle"><span class="doc_prefix">default#</span>last</h2><p>The container’s last child.</p>
<pre><code class="code">rule.last === rule.nodes[rule.nodes.length - <span class="code_number">1</span>]</code></pre>
<h2 id="default-after" class="doc_subtitle"><span class="doc_prefix">default#</span>after()</h2><p>Insert new node after current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertAfter(node, add)</code>.</p>
<pre><code class="code">decl.after(<span class="code_string">'color: black'</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#atruleprops">AtRuleProps</a> | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | default | default[]</td><td>New node.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-append" class="doc_subtitle"><span class="doc_prefix">default#</span>append()</h2><p>Inserts new nodes to the end of the container.</p>
<pre><code class="code"><span class="code_keyword">const</span> decl1 = <span class="code_keyword">new</span> Declaration({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> })
<span class="code_keyword">const</span> decl2 = <span class="code_keyword">new</span> Declaration({ <span class="code_attr">prop</span>: <span class="code_string">'background-color'</span>, <span class="code_attr">value</span>: <span class="code_string">'white'</span> })
rule.append(decl1, decl2)

root.append({ <span class="code_attr">name</span>: <span class="code_string">'charset'</span>, <span class="code_attr">params</span>: <span class="code_string">'"UTF-8"'</span> })  <span class="code_comment">// at-rule</span>
root.append({ <span class="code_attr">selector</span>: <span class="code_string">'a'</span> })                       <span class="code_comment">// rule</span>
rule.append({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> })       <span class="code_comment">// declaration</span>
rule.append({ <span class="code_attr">text</span>: <span class="code_string">'Comment'</span> })                     <span class="code_comment">// comment</span>

root.append(<span class="code_string">'a {}'</span>)
root.first.append(<span class="code_string">'color: black; z-index: 1'</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td>(string | <a href="#atruleprops">AtRuleProps</a> | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | default | default[] | <a href="#childprops">ChildProps</a>[] | string[])[]</td><td>New nodes.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-before" class="doc_subtitle"><span class="doc_prefix">default#</span>before()</h2><p>Insert new node before current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertBefore(node, add)</code>.</p>
<pre><code class="code">decl.before(<span class="code_string">'content: ""'</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#atruleprops">AtRuleProps</a> | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | default | default[]</td><td>New node.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-cleanraws" class="doc_subtitle"><span class="doc_prefix">default#</span>cleanRaws()</h2><p>Clear the code style properties for the node and its children.</p>
<pre><code class="code">node.raws.before  <span class="code_comment">//=> ' '</span>
node.cleanRaws()
node.raws.before  <span class="code_comment">//=> undefined</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>keepBetween</code></td><td>boolean</td><td>Keep the <code>raws.between</code> symbols.
</td></tr></table><h2 id="default-clone" class="doc_subtitle"><span class="doc_prefix">default#</span>clone()</h2><p>Returns an exact clone of the node.</p>
<p>The resulting cloned node and its (cloned) children will retain
code style properties.</p>
<pre><code class="code">decl.raws.before    <span class="code_comment">//=> "\n  "</span>
<span class="code_keyword">const</span> cloned = decl.clone({ <span class="code_attr">prop</span>: <span class="code_string">'-moz-'</span> + decl.prop })
cloned.raws.before  <span class="code_comment">//=> "\n  "</span>
cloned.toString()   <span class="code_comment">//=> -moz-transform: scale(0)</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>object</td><td>New properties to override in the clone.
</td></tr></table><p>Returns <code>default</code>. Clone of the node.
</p><h2 id="default-cloneafter" class="doc_subtitle"><span class="doc_prefix">default#</span>cloneAfter()</h2><p>Shortcut to clone the node and insert the resulting cloned node
after the current node.</p>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>object</td><td>New properties to override in the clone.
</td></tr></table><p>Returns <code>default</code>. New node.
</p><h2 id="default-clonebefore" class="doc_subtitle"><span class="doc_prefix">default#</span>cloneBefore()</h2><p>Shortcut to clone the node and insert the resulting cloned node
before the current node.</p>
<pre><code class="code">decl.cloneBefore({ <span class="code_attr">prop</span>: <span class="code_string">'-moz-'</span> + decl.prop })</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>object</td><td>Mew properties to override in the clone.
</td></tr></table><p>Returns <code>default</code>. New node
</p><h2 id="default-each" class="doc_subtitle"><span class="doc_prefix">default#</span>each()</h2><p>Iterates through the container’s immediate children,
calling <code>callback</code> for each child.</p>
<p>Returning <code>false</code> in the callback will break iteration.</p>
<p>This method only iterates through the container’s immediate children.
If you need to recursively iterate through all the container’s descendant
nodes, use <code><a href="#container-walk">Container#walk</a></code>.</p>
<p>Unlike the for <code>{}</code>-cycle or <code>Array#forEach</code> this iterator is safe
if you are mutating the array of child nodes during iteration.
PostCSS will adjust the current index to match the mutations.</p>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(<span class="code_string">'a { color: black; z-index: 1 }'</span>)
<span class="code_keyword">const</span> rule = root.first

<span class="code_keyword">for</span> (<span class="code_keyword">const</span> decl <span class="code_keyword">of</span> rule.nodes) {
  decl.cloneBefore({ <span class="code_attr">prop</span>: <span class="code_string">'-webkit-'</span> + decl.prop })
  <span class="code_comment">// Cycle will be infinite, because cloneBefore moves the current node</span>
  <span class="code_comment">// to the next index</span>
}

rule.each(<span class="code_function"><span class="code_params">decl</span> =></span> {
  decl.cloneBefore({ <span class="code_attr">prop</span>: <span class="code_string">'-webkit-'</span> + decl.prop })
  <span class="code_comment">// Will be executed only for color and z-index</span>
})</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>callback</code></td><td>(node: <a href="#childnode">ChildNode</a>, index: number) => false | void</td><td>Iterator receives each node and index.
</td></tr></table><p>Returns <code>void | false</code>. Returns <code>false</code> if iteration was broke.
</p><h2 id="default-error" class="doc_subtitle"><span class="doc_prefix">default#</span>error()</h2><p>Returns a <code><a href="#csssyntaxerror">CssSyntaxError</a></code> instance containing the original position
of the node in the source, showing line and column numbers and also
a small excerpt to facilitate debugging.</p>
<p>If present, an input source map will be used to get the original position
of the source, even from a previous compilation step
(e.g., from Sass compilation).</p>
<p>This method produces very useful error messages.</p>
<pre><code class="code"><span class="code_keyword">if</span> (!variables[name]) {
  <span class="code_keyword">throw</span> decl.error(<span class="code_string">`Unknown variable <span class="code_subst">${name}</span>`</span>, { <span class="code_attr">word</span>: name })
  <span class="code_comment">// CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black</span>
  <span class="code_comment">//   color: $black</span>
  <span class="code_comment">// a</span>
  <span class="code_comment">//          ^</span>
  <span class="code_comment">//   background: white</span>
}</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>message</code></td><td>string</td><td>Error description.
</td></tr><tr><td><code>options</code></td><td><a href="#nodeerroroptions">NodeErrorOptions</a></td><td></td></tr></table><p>Returns <code>default</code>. Error object to throw it.
</p><h2 id="default-every" class="doc_subtitle"><span class="doc_prefix">default#</span>every()</h2><p>Returns <code>true</code> if callback returns <code>true</code>
for all of the container’s children.</p>
<pre><code class="code"><span class="code_keyword">const</span> noPrefixes = rule.every(<span class="code_function"><span class="code_params">i</span> =></span> i.prop[<span class="code_number">0</span>] !== <span class="code_string">'-'</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>condition</code></td><td>(node: <a href="#childnode">ChildNode</a>, index: number, nodes: <a href="#childnode">ChildNode</a>[]) => boolean</td><td>Iterator returns true or false.
</td></tr></table><p>Returns <code>boolean</code>. Is every child pass condition.
</p><h2 id="default-index" class="doc_subtitle"><span class="doc_prefix">default#</span>index()</h2><p>Returns a <code>child</code>’s index within the <code><a href="#container-nodes">Container#nodes</a></code> array.</p>
<pre><code class="code">rule.index( rule.nodes[<span class="code_number">2</span>] ) <span class="code_comment">//=> 2</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td>number | default | default | default | default</td><td>Child of the current container.
</td></tr></table><p>Returns <code>number</code>. Child index.
</p><h2 id="default-insertafter" class="doc_subtitle"><span class="doc_prefix">default#</span>insertAfter()</h2><p>Insert new node after old node within the container.</p>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>oldNode</code></td><td>number | default | default | default | default</td><td>Child or child’s index.
</td></tr><tr><td><code>newNode</code></td><td>string | <a href="#atruleprops">AtRuleProps</a> | default | default | default | default | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | <a href="#childnode">ChildNode</a>[] | <a href="#childprops">ChildProps</a>[] | string[]</td><td>New node.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-insertbefore" class="doc_subtitle"><span class="doc_prefix">default#</span>insertBefore()</h2><p>Insert new node before old node within the container.</p>
<pre><code class="code">rule.insertBefore(decl, decl.clone({ <span class="code_attr">prop</span>: <span class="code_string">'-webkit-'</span> + decl.prop }))</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>oldNode</code></td><td>number | default | default | default | default</td><td>Child or child’s index.
</td></tr><tr><td><code>newNode</code></td><td>string | <a href="#atruleprops">AtRuleProps</a> | default | default | default | default | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | <a href="#childnode">ChildNode</a>[] | <a href="#childprops">ChildProps</a>[] | string[]</td><td>New node.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-next" class="doc_subtitle"><span class="doc_prefix">default#</span>next()</h2><p>Returns the next child of the node’s parent.
Returns <code>undefined</code> if the current node is the last child.</p>
<pre><code class="code"><span class="code_keyword">if</span> (comment.text === <span class="code_string">'delete next'</span>) {
  <span class="code_keyword">const</span> next = comment.next()
  <span class="code_keyword">if</span> (next) {
    next.remove()
  }
}</code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code><a href="#childnode">ChildNode</a></code>. Next node.
</p><h2 id="default-positioninside" class="doc_subtitle"><span class="doc_prefix">default#</span>positionInside()</h2><p>Convert string index to line/column.</p>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>number</td><td>The symbol number in the node’s string.
</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. Symbol position in file.
</p><h2 id="default-prepend" class="doc_subtitle"><span class="doc_prefix">default#</span>prepend()</h2><p>Inserts new nodes to the start of the container.</p>
<pre><code class="code"><span class="code_keyword">const</span> decl1 = <span class="code_keyword">new</span> Declaration({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> })
<span class="code_keyword">const</span> decl2 = <span class="code_keyword">new</span> Declaration({ <span class="code_attr">prop</span>: <span class="code_string">'background-color'</span>, <span class="code_attr">value</span>: <span class="code_string">'white'</span> })
rule.prepend(decl1, decl2)

root.append({ <span class="code_attr">name</span>: <span class="code_string">'charset'</span>, <span class="code_attr">params</span>: <span class="code_string">'"UTF-8"'</span> })  <span class="code_comment">// at-rule</span>
root.append({ <span class="code_attr">selector</span>: <span class="code_string">'a'</span> })                       <span class="code_comment">// rule</span>
rule.append({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> })       <span class="code_comment">// declaration</span>
rule.append({ <span class="code_attr">text</span>: <span class="code_string">'Comment'</span> })                     <span class="code_comment">// comment</span>

root.append(<span class="code_string">'a {}'</span>)
root.first.append(<span class="code_string">'color: black; z-index: 1'</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td>(string | <a href="#atruleprops">AtRuleProps</a> | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | default | default[] | <a href="#childprops">ChildProps</a>[] | string[])[]</td><td>New nodes.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-prev" class="doc_subtitle"><span class="doc_prefix">default#</span>prev()</h2><p>Returns the previous child of the node’s parent.
Returns <code>undefined</code> if the current node is the first child.</p>
<pre><code class="code"><span class="code_keyword">const</span> annotation = decl.prev()
<span class="code_keyword">if</span> (annotation.type === <span class="code_string">'comment'</span>) {
  readAnnotation(annotation.text)
}</code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code><a href="#childnode">ChildNode</a></code>. Previous node.
</p><h2 id="default-push" class="doc_subtitle"><span class="doc_prefix">default#</span>push()</h2><p>Add child to the end of the node.</p>
<pre><code class="code">rule.push(<span class="code_keyword">new</span> Declaration({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> }))</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td><a href="#childnode">ChildNode</a></td><td>New node.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-raw" class="doc_subtitle"><span class="doc_prefix">default#</span>raw()</h2><p>Returns a <code><a href="#node-raws">Node#raws</a></code> value. If the node is missing
the code style property (because the node was manually built or cloned),
PostCSS will try to autodetect the code style property by looking
at other nodes in the tree.</p>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(<span class="code_string">'a { background: white }'</span>)
root.nodes[<span class="code_number">0</span>].append({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> })
root.nodes[<span class="code_number">0</span>].nodes[<span class="code_number">1</span>].raws.before   <span class="code_comment">//=> undefined</span>
root.nodes[<span class="code_number">0</span>].nodes[<span class="code_number">1</span>].raw(<span class="code_string">'before'</span>) <span class="code_comment">//=> ' '</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>prop</code></td><td>string</td><td>Name of code style property.
</td></tr><tr><td><code>defaultType</code></td><td>string</td><td>Name of default value, it can be missed
if the value is the same as prop.
</td></tr></table><p>Returns <code>string</code>. Code style value.
</p><h2 id="default-remove" class="doc_subtitle"><span class="doc_prefix">default#</span>remove()</h2><p>Removes the node from its parent and cleans the parent properties
from the node and its children.</p>
<pre><code class="code"><span class="code_keyword">if</span> (decl.prop.match(<span class="code_regexp">/^-webkit-/</span>)) {
  decl.remove()
}</code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>default</code>. Node to make calls chain.
</p><h2 id="default-removeall" class="doc_subtitle"><span class="doc_prefix">default#</span>removeAll()</h2><p>Removes all children from the container
and cleans their parent properties.</p>
<pre><code class="code">rule.removeAll()
rule.nodes.length <span class="code_comment">//=> 0</span></code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-removechild" class="doc_subtitle"><span class="doc_prefix">default#</span>removeChild()</h2><p>Removes node from the container and cleans the parent properties
from the node and its children.</p>
<pre><code class="code">rule.nodes.length  <span class="code_comment">//=> 5</span>
rule.removeChild(decl)
rule.nodes.length  <span class="code_comment">//=> 4</span>
decl.parent        <span class="code_comment">//=> undefined</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td>number | default | default | default | default</td><td>Child or child’s index.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-replacevalues" class="doc_subtitle"><span class="doc_prefix">default#</span>replaceValues()</h2><p>Passes all declaration values within the container that match pattern
through callback, replacing those values with the returned result
of callback.</p>
<p>This method is useful if you are using a custom unit or function
and need to iterate through all values.</p>
<pre><code class="code">root.replaceValues(<span class="code_regexp">/\d+rem/</span>, { <span class="code_attr">fast</span>: <span class="code_string">'rem'</span> }, <span class="code_function"><span class="code_params">string</span> =></span> {
  <span class="code_keyword">return</span> <span class="code_number">15</span> * <span class="code_built_in">parseInt</span>(string) + <span class="code_string">'px'</span>
})</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>pattern</code></td><td>string | RegExp</td><td>Replace pattern.
</td></tr><tr><td><code>options</code></td><td><a href="#valueoptions">ValueOptions</a></td><td></td></tr><tr><td><code>replaced</code></td><td>string | (substring: string, args: any[]) => string</td><td></td></tr></table><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>pattern</code></td><td>string | RegExp</td><td>Replace pattern.
</td></tr><tr><td><code>replaced</code></td><td>string | (substring: string, args: any[]) => string</td><td></td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-replacewith" class="doc_subtitle"><span class="doc_prefix">default#</span>replaceWith()</h2><p>Inserts node(s) before the current node and removes the current node.</p>
<pre><code class="code">AtRule: {
  <span class="code_attr">mixin</span>: <span class="code_function"><span class="code_params">atrule</span> =></span> {
    atrule.replaceWith(mixinRules[atrule.params])
  }
}</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td>(<a href="#atruleprops">AtRuleProps</a> | default | default | default | default | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | <a href="#childnode">ChildNode</a>[] | <a href="#childprops">ChildProps</a>[])[]</td><td>Mode(s) to replace current one.
</td></tr></table><p>Returns <code>default</code>. Current node to methods chain.
</p><h2 id="default-root" class="doc_subtitle"><span class="doc_prefix">default#</span>root()</h2><p>Finds the Root instance of the node’s tree.</p>
<pre><code class="code">root.nodes[<span class="code_number">0</span>].nodes[<span class="code_number">0</span>].root() === root</code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>default</code>. Root parent.
</p><h2 id="default-some" class="doc_subtitle"><span class="doc_prefix">default#</span>some()</h2><p>Returns <code>true</code> if callback returns <code>true</code> for (at least) one
of the container’s children.</p>
<pre><code class="code"><span class="code_keyword">const</span> hasPrefix = rule.some(<span class="code_function"><span class="code_params">i</span> =></span> i.prop[<span class="code_number">0</span>] === <span class="code_string">'-'</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>condition</code></td><td>(node: <a href="#childnode">ChildNode</a>, index: number, nodes: <a href="#childnode">ChildNode</a>[]) => boolean</td><td>Iterator returns true or false.
</td></tr></table><p>Returns <code>boolean</code>. Is some child pass condition.
</p><h2 id="default-tojson" class="doc_subtitle"><span class="doc_prefix">default#</span>toJSON()</h2><p>Fix circular links on <code>JSON.stringify()</code>.</p>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>object</code>. Cleaned object.
</p><h2 id="default-tostring" class="doc_subtitle"><span class="doc_prefix">default#</span>toString()</h2><p>Returns a CSS string representing the node.</p>
<pre><code class="code"><span class="code_keyword">new</span> Rule({ <span class="code_attr">selector</span>: <span class="code_string">'a'</span> }).toString() <span class="code_comment">//=> "a {}"</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>stringifier</code></td><td><a href="#stringifier">Stringifier</a> | <a href="#syntax">Syntax</a></td><td>A syntax to use in string generation.
</td></tr></table><p>Returns <code>string</code>. CSS string of this node.
</p><h2 id="default-walk" class="doc_subtitle"><span class="doc_prefix">default#</span>walk()</h2><p>Traverses the container’s descendant nodes, calling callback
for each node.</p>
<p>Like container.each(), this method is safe to use
if you are mutating arrays during iteration.</p>
<p>If you only need to iterate through the container’s immediate children,
use <code><a href="#container-each">Container#each</a></code>.</p>
<pre><code class="code">root.walk(<span class="code_function"><span class="code_params">node</span> =></span> {
  <span class="code_comment">// Traverses all descendant nodes.</span>
})</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>callback</code></td><td>(node: <a href="#childnode">ChildNode</a>, index: number) => false | void</td><td>Iterator receives each node and index.
</td></tr></table><p>Returns <code>void | false</code>. Returns <code>false</code> if iteration was broke.
</p><h2 id="default-walkatrules" class="doc_subtitle"><span class="doc_prefix">default#</span>walkAtRules()</h2><p>Traverses the container’s descendant nodes, calling callback
for each at-rule node.</p>
<p>If you pass a filter, iteration will only happen over at-rules
that have matching names.</p>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<pre><code class="code">root.walkAtRules(<span class="code_function"><span class="code_params">rule</span> =></span> {
  <span class="code_keyword">if</span> (isOld(rule.name)) rule.remove()
})

<span class="code_keyword">let</span> first = <span class="code_literal">false</span>
root.walkAtRules(<span class="code_string">'charset'</span>, <span class="code_function"><span class="code_params">rule</span> =></span> {
  <span class="code_keyword">if</span> (!first) {
    first = <span class="code_literal">true</span>
  } <span class="code_keyword">else</span> {
    rule.remove()
  }
})</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nameFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>(atRule: default, index: number) => false | void</td><td>Iterator receives each node and index.
</td></tr></table><p>Returns <code>void | false</code>. Returns <code>false</code> if iteration was broke.
</p><h2 id="default-walkcomments" class="doc_subtitle"><span class="doc_prefix">default#</span>walkComments()</h2><p>Traverses the container’s descendant nodes, calling callback
for each comment node.</p>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<pre><code class="code">root.walkComments(<span class="code_function"><span class="code_params">comment</span> =></span> {
  comment.remove()
})</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>callback</code></td><td>(comment: default, indexed: number) => false | void</td><td>Iterator receives each node and index.
</td></tr></table><p>Returns <code>void | false</code>. Returns <code>false</code> if iteration was broke.
</p><h2 id="default-walkdecls" class="doc_subtitle"><span class="doc_prefix">default#</span>walkDecls()</h2><p>Traverses the container’s descendant nodes, calling callback
for each declaration node.</p>
<p>If you pass a filter, iteration will only happen over declarations
with matching properties.</p>
<pre><code class="code">root.walkDecls(<span class="code_function"><span class="code_params">decl</span> =></span> {
  checkPropertySupport(decl.prop)
})

root.walkDecls(<span class="code_string">'border-radius'</span>, <span class="code_function"><span class="code_params">decl</span> =></span> {
  decl.remove()
})

root.walkDecls(<span class="code_regexp">/^background/</span>, <span class="code_function"><span class="code_params">decl</span> =></span> {
  decl.value = takeFirstColorFromGradient(decl.value)
})</code></pre>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>propFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>(decl: default, index: number) => false | void</td><td>Iterator receives each node and index.
</td></tr></table><p>Returns <code>void | false</code>. Returns <code>false</code> if iteration was broke.
</p><h2 id="default-walkrules" class="doc_subtitle"><span class="doc_prefix">default#</span>walkRules()</h2><p>Traverses the container’s descendant nodes, calling callback
for each rule node.</p>
<p>If you pass a filter, iteration will only happen over rules
with matching selectors.</p>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<pre><code class="code"><span class="code_keyword">const</span> selectors = []
root.walkRules(<span class="code_function"><span class="code_params">rule</span> =></span> {
  selectors.push(rule.selector)
})
<span class="code_built_in">console</span>.log(<span class="code_string">`Your CSS uses <span class="code_subst">${ selectors.length }</span> selectors`</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>selectorFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>(atRule: default, index: number) => false | void</td><td>Iterator receives each node and index.
</td></tr></table><p>Returns <code>void | false</code>. Returns <code>false</code> if iteration was broke.
</p><h2 id="default-warn" class="doc_subtitle"><span class="doc_prefix">default#</span>warn()</h2><p>This method is provided as a convenience wrapper for <code><a href="#result-warn">Result#warn</a></code>.</p>
<pre><code class="code">  Declaration: {
    <span class="code_attr">bad</span>: <span class="code_function">(<span class="code_params">decl, { result }</span>) =></span> {
      decl.warn(result, <span class="code_string">'Deprecated property bad'</span>)
    }
  }</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>result</code></td><td>default</td><td>The <code><a href="#result">Result</a></code> instance that will receive the warning.
</td></tr><tr><td><code>text</code></td><td>string</td><td>Warning message.
</td></tr><tr><td><code>opts</code></td><td><a href="#warningoptions">WarningOptions</a></td><td>Warning Options.
</td></tr></table></section><section class="doc"><h1 id="default" class="doc_title">default</h1><p>The CSS parser throws this error for broken CSS.</p>
<p>Custom parsers can throw this error for broken custom syntax using
the <code><a href="#node-error">Node#error</a></code> method.</p>
<p>PostCSS will use the input source map to detect the original error location.
If you wrote a Sass file, compiled it to CSS and then parsed it with PostCSS,
PostCSS will show the original position in the Sass file.</p>
<p>If you need the position in the PostCSS input
(e.g., to debug the previous compiler), use <code>error.input.file</code>.</p>
<pre><code class="code"><span class="code_comment">// Raising error from plugin</span>
<span class="code_keyword">throw</span> node.error(<span class="code_string">'Unknown variable'</span>, { <span class="code_attr">plugin</span>: <span class="code_string">'postcss-vars'</span> })</code></pre>
<pre><code class="code"><span class="code_comment">// Catching and checking syntax error</span>
<span class="code_keyword">try</span> {
  postcss.parse(<span class="code_string">'a{'</span>)
} <span class="code_keyword">catch</span> (error) {
  <span class="code_keyword">if</span> (error.name === <span class="code_string">'CssSyntaxError'</span>) {
    error <span class="code_comment">//=> CssSyntaxError</span>
  }
}</code></pre>
<h2 id="default-column" class="doc_subtitle"><span class="doc_prefix">default#</span>column</h2><p>Source column of the error.</p>
<pre><code class="code">error.column       <span class="code_comment">//=> 1</span>
error.input.column <span class="code_comment">//=> 4</span></code></pre>
<p>PostCSS will use the input source map to detect the original location.
If you need the position in the PostCSS input, use <code>error.input.column</code>.</p>
<p>Type: number.</p><h2 id="default-file" class="doc_subtitle"><span class="doc_prefix">default#</span>file</h2><p>Absolute path to the broken file.</p>
<pre><code class="code">error.file       <span class="code_comment">//=> 'a.sass'</span>
error.input.file <span class="code_comment">//=> 'a.css'</span></code></pre>
<p>PostCSS will use the input source map to detect the original location.
If you need the position in the PostCSS input, use <code>error.input.file</code>.</p>
<p>Type: string.</p><h2 id="default-input" class="doc_subtitle"><span class="doc_prefix">default#</span>input</h2><p>Input object with PostCSS internal information
about input file. If input has source map
from previous tool, PostCSS will use origin
(for example, Sass) source. You can use this
object to get PostCSS input source.</p>
<pre><code class="code">error.input.file <span class="code_comment">//=> 'a.css'</span>
error.file       <span class="code_comment">//=> 'a.sass'</span></code></pre>
<p>Type: <a href="#fileposition">FilePosition</a>.</p><h2 id="default-line" class="doc_subtitle"><span class="doc_prefix">default#</span>line</h2><p>Source line of the error.</p>
<pre><code class="code">error.line       <span class="code_comment">//=> 2</span>
error.input.line <span class="code_comment">//=> 4</span></code></pre>
<p>PostCSS will use the input source map to detect the original location.
If you need the position in the PostCSS input, use <code>error.input.line</code>.</p>
<p>Type: number.</p><h2 id="default-message" class="doc_subtitle"><span class="doc_prefix">default#</span>message</h2><p>Full error text in the GNU error format
with plugin, file, line and column.</p>
<pre><code class="code">error.message <span class="code_comment">//=> 'a.css:1:1: Unclosed block'</span></code></pre>
<p>Type: string.</p><h2 id="default-name" class="doc_subtitle"><span class="doc_prefix">default#</span>name</h2><p>Always equal to <code>'CssSyntaxError'</code>. You should always check error type
by <code>error.name === 'CssSyntaxError'</code>
instead of <code>error instanceof CssSyntaxError</code>,
because npm could have several PostCSS versions.</p>
<pre><code class="code"><span class="code_keyword">if</span> (error.name === <span class="code_string">'CssSyntaxError'</span>) {
  error <span class="code_comment">//=> CssSyntaxError</span>
}</code></pre>
<p>Type: "<a href="#csssyntaxerror">CssSyntaxError</a>".</p><h2 id="default-plugin" class="doc_subtitle"><span class="doc_prefix">default#</span>plugin</h2><p>Plugin name, if error came from plugin.</p>
<pre><code class="code">error.plugin <span class="code_comment">//=> 'postcss-vars'</span></code></pre>
<p>Type: string.</p><h2 id="default-reason" class="doc_subtitle"><span class="doc_prefix">default#</span>reason</h2><p>Error message.</p>
<pre><code class="code">error.message <span class="code_comment">//=> 'Unclosed block'</span></code></pre>
<p>Type: string.</p><h2 id="default-source" class="doc_subtitle"><span class="doc_prefix">default#</span>source</h2><p>Source code of the broken file.</p>
<pre><code class="code">error.source       <span class="code_comment">//=> 'a { b {} }'</span>
error.input.column <span class="code_comment">//=> 'a b { }'</span></code></pre>
<p>Type: string.</p><h2 id="default-showsourcecode" class="doc_subtitle"><span class="doc_prefix">default#</span>showSourceCode()</h2><p>Returns a few lines of CSS source that caused the error.</p>
<p>If the CSS has an input source map without <code>sourceContent</code>,
this method will return an empty string.</p>
<pre><code class="code">error.showSourceCode() <span class="code_comment">//=> "  4 | }</span>
                       <span class="code_comment">//      5 | a {</span>
                       <span class="code_comment">//    > 6 |   bad</span>
                       <span class="code_comment">//        |   ^</span>
                       <span class="code_comment">//      7 | }</span>
                       <span class="code_comment">//      8 | b {"</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>color</code></td><td>boolean</td><td>Whether arrow will be colored red by terminal
color codes. By default, PostCSS will detect
color support by <code>process.stdout.isTTY</code>
and <code>process.env.NODE_DISABLE_COLORS</code>.
</td></tr></table><p>Returns <code>string</code>. Few lines of CSS source that caused the error.
</p><h2 id="default-tostring" class="doc_subtitle"><span class="doc_prefix">default#</span>toString()</h2><p>Returns error position, message and source code of the broken part.</p>
<pre><code class="code">error.toString() <span class="code_comment">//=> "CssSyntaxError: app.css:1:1: Unclosed block</span>
                 <span class="code_comment">//    > 1 | a {</span>
                 <span class="code_comment">//        | ^"</span></code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>string</code>. Error position, message and source code.
</p></section><section class="doc"><h1 id="default" class="doc_title">default</h1><p>Represents a CSS declaration.</p>
<pre><code class="code">Once (root, { Declaration }) {
  <span class="code_keyword">let</span> color = <span class="code_keyword">new</span> Declaration({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> })
  root.append(color)
}</code></pre>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(<span class="code_string">'a { color: black }'</span>)
<span class="code_keyword">const</span> decl = root.first.first
decl.type       <span class="code_comment">//=> 'decl'</span>
decl.toString() <span class="code_comment">//=> ' color: black'</span></code></pre>
<h2 id="default-important" class="doc_subtitle"><span class="doc_prefix">default#</span>important</h2><p><code>true</code> if the declaration has an <code>!important</code> annotation.</p>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(<span class="code_string">'a { color: black !important; color: red }'</span>)
root.first.first.important <span class="code_comment">//=> true</span>
root.first.last.important  <span class="code_comment">//=> undefined</span></code></pre>
<p>Type: boolean.</p><h2 id="default-parent" class="doc_subtitle"><span class="doc_prefix">default#</span>parent</h2><p>The node’s parent node.</p>
<pre><code class="code">root.nodes[<span class="code_number">0</span>].parent === root</code></pre>
<p>Type: default.</p><h2 id="default-prop" class="doc_subtitle"><span class="doc_prefix">default#</span>prop</h2><p>The declaration's property name.</p>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(<span class="code_string">'a { color: black }'</span>)
<span class="code_keyword">const</span> decl = root.first.first
decl.prop <span class="code_comment">//=> 'color'</span></code></pre>
<p>Type: string.</p><h2 id="default-raws" class="doc_subtitle"><span class="doc_prefix">default#</span>raws</h2><p>Information to generate byte-to-byte equal node string as it was
in the origin input.</p>
<p>Every parser saves its own properties,
but the default CSS parser uses:</p>
<ul>
<li><code>before</code>: the space symbols before the node. It also stores <code>*</code>
and <code>_</code> symbols before the declaration (IE hack).</li>
<li><code>after</code>: the space symbols after the last child of the node
to the end of the node.</li>
<li><code>between</code>: the symbols between the property and value
for declarations, selector and <code>{</code> for rules, or last parameter
and <code>{</code> for at-rules.</li>
<li><code>semicolon</code>: contains true if the last child has
an (optional) semicolon.</li>
<li><code>afterName</code>: the space between the at-rule name and its parameters.</li>
<li><code>left</code>: the space symbols between <code>/*</code> and the comment’s text.</li>
<li><code>right</code>: the space symbols between the comment’s text
and <code>*/</code>.</li>
<li><code>important</code>: the content of the important statement,
if it is not just <code>!important</code>.</li>
</ul>
<p>PostCSS cleans selectors, declaration values and at-rule parameters
from comments and extra spaces, but it stores origin content in raws
properties. As such, if you don’t change a declaration’s value,
PostCSS will use the raw value with comments.</p>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(<span class="code_string">'a {\n  color:black\n}'</span>)
root.first.first.raws <span class="code_comment">//=> { before: '\n  ', between: ':' }</span></code></pre>
<p>Type: <a href="#declarationraws">DeclarationRaws</a>.</p><h2 id="default-source" class="doc_subtitle"><span class="doc_prefix">default#</span>source</h2><p>The input source of the node.</p>
<p>The property is used in source map generation.</p>
<p>If you create a node manually (e.g., with <code>postcss.decl()</code>),
that node will not have a <code>source</code> property and will be absent
from the source map. For this reason, the plugin developer should
consider cloning nodes to create new ones (in which case the new node’s
source will reference the original, cloned node) or setting
the <code>source</code> property manually.</p>
<pre><code class="code">decl.source.input.from <span class="code_comment">//=> '/home/ai/a.sass'</span>
decl.source.start      <span class="code_comment">//=> { line: 10, column: 2 }</span>
decl.source.end        <span class="code_comment">//=> { line: 10, column: 12 }</span></code></pre>
<pre><code class="code"><span class="code_comment">// Bad</span>
<span class="code_keyword">const</span> prefixed = postcss.decl({
  <span class="code_attr">prop</span>: <span class="code_string">'-moz-'</span> + decl.prop,
  <span class="code_attr">value</span>: decl.value
})

<span class="code_comment">// Good</span>
<span class="code_keyword">const</span> prefixed = decl.clone({ <span class="code_attr">prop</span>: <span class="code_string">'-moz-'</span> + decl.prop })</code></pre>
<pre><code class="code"><span class="code_keyword">if</span> (atrule.name === <span class="code_string">'add-link'</span>) {
  <span class="code_keyword">const</span> rule = postcss.rule({ <span class="code_attr">selector</span>: <span class="code_string">'a'</span>, <span class="code_attr">source</span>: atrule.source })
  atrule.parent.insertBefore(atrule, rule)
}</code></pre>
<p>Type: <a href="#source">Source</a>.</p><h2 id="default-type" class="doc_subtitle"><span class="doc_prefix">default#</span>type</h2><p>tring representing the node’s type. Possible values are <code>root</code>, <code>atrule</code>,
<code>rule</code>, <code>decl</code>, or <code>comment</code>.</p>
<pre><code class="code"><span class="code_keyword">new</span> Declaration({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> }).type <span class="code_comment">//=> 'decl'</span></code></pre>
<p>Type: "decl".</p><h2 id="default-value" class="doc_subtitle"><span class="doc_prefix">default#</span>value</h2><p>The declaration’s value.</p>
<p>This value will be cleaned of comments. If the source value contained
comments, those comments will be available in the <code>raws</code> property.
If you have not changed the value, the result of <code>decl.toString()</code>
will include the original raws value (comments and all).</p>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(<span class="code_string">'a { color: black }'</span>)
<span class="code_keyword">const</span> decl = root.first.first
decl.value <span class="code_comment">//=> 'black'</span></code></pre>
<p>Type: string.</p><h2 id="default-variable" class="doc_subtitle"><span class="doc_prefix">default#</span>variable</h2><p><code>true</code> if declaration is declaration of CSS Custom Property
or Sass variable.</p>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(<span class="code_string">':root { --one: 1 }'</span>)
<span class="code_keyword">let</span> one = root.first.first
one.variable <span class="code_comment">//=> true</span></code></pre>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(<span class="code_string">'$one: 1'</span>)
<span class="code_keyword">let</span> one = root.first
one.variable <span class="code_comment">//=> true</span></code></pre>
<p>Type: boolean.</p><h2 id="default-after" class="doc_subtitle"><span class="doc_prefix">default#</span>after()</h2><p>Insert new node after current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertAfter(node, add)</code>.</p>
<pre><code class="code">decl.after(<span class="code_string">'color: black'</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#atruleprops">AtRuleProps</a> | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | default | default[]</td><td>New node.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-before" class="doc_subtitle"><span class="doc_prefix">default#</span>before()</h2><p>Insert new node before current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertBefore(node, add)</code>.</p>
<pre><code class="code">decl.before(<span class="code_string">'content: ""'</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#atruleprops">AtRuleProps</a> | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | default | default[]</td><td>New node.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-cleanraws" class="doc_subtitle"><span class="doc_prefix">default#</span>cleanRaws()</h2><p>Clear the code style properties for the node and its children.</p>
<pre><code class="code">node.raws.before  <span class="code_comment">//=> ' '</span>
node.cleanRaws()
node.raws.before  <span class="code_comment">//=> undefined</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>keepBetween</code></td><td>boolean</td><td>Keep the <code>raws.between</code> symbols.
</td></tr></table><h2 id="default-clone" class="doc_subtitle"><span class="doc_prefix">default#</span>clone()</h2><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#declarationprops">DeclarationProps</a>></td><td>New properties to override in the clone.
</td></tr></table><p>Returns <code>default</code>. </p><h2 id="default-cloneafter" class="doc_subtitle"><span class="doc_prefix">default#</span>cloneAfter()</h2><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#declarationprops">DeclarationProps</a>></td><td>New properties to override in the clone.
</td></tr></table><p>Returns <code>default</code>. </p><h2 id="default-clonebefore" class="doc_subtitle"><span class="doc_prefix">default#</span>cloneBefore()</h2><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#declarationprops">DeclarationProps</a>></td><td>Mew properties to override in the clone.
</td></tr></table><p>Returns <code>default</code>. </p><h2 id="default-error" class="doc_subtitle"><span class="doc_prefix">default#</span>error()</h2><p>Returns a <code><a href="#csssyntaxerror">CssSyntaxError</a></code> instance containing the original position
of the node in the source, showing line and column numbers and also
a small excerpt to facilitate debugging.</p>
<p>If present, an input source map will be used to get the original position
of the source, even from a previous compilation step
(e.g., from Sass compilation).</p>
<p>This method produces very useful error messages.</p>
<pre><code class="code"><span class="code_keyword">if</span> (!variables[name]) {
  <span class="code_keyword">throw</span> decl.error(<span class="code_string">`Unknown variable <span class="code_subst">${name}</span>`</span>, { <span class="code_attr">word</span>: name })
  <span class="code_comment">// CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black</span>
  <span class="code_comment">//   color: $black</span>
  <span class="code_comment">// a</span>
  <span class="code_comment">//          ^</span>
  <span class="code_comment">//   background: white</span>
}</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>message</code></td><td>string</td><td>Error description.
</td></tr><tr><td><code>options</code></td><td><a href="#nodeerroroptions">NodeErrorOptions</a></td><td></td></tr></table><p>Returns <code>default</code>. Error object to throw it.
</p><h2 id="default-next" class="doc_subtitle"><span class="doc_prefix">default#</span>next()</h2><p>Returns the next child of the node’s parent.
Returns <code>undefined</code> if the current node is the last child.</p>
<pre><code class="code"><span class="code_keyword">if</span> (comment.text === <span class="code_string">'delete next'</span>) {
  <span class="code_keyword">const</span> next = comment.next()
  <span class="code_keyword">if</span> (next) {
    next.remove()
  }
}</code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code><a href="#childnode">ChildNode</a></code>. Next node.
</p><h2 id="default-positioninside" class="doc_subtitle"><span class="doc_prefix">default#</span>positionInside()</h2><p>Convert string index to line/column.</p>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>number</td><td>The symbol number in the node’s string.
</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. Symbol position in file.
</p><h2 id="default-prev" class="doc_subtitle"><span class="doc_prefix">default#</span>prev()</h2><p>Returns the previous child of the node’s parent.
Returns <code>undefined</code> if the current node is the first child.</p>
<pre><code class="code"><span class="code_keyword">const</span> annotation = decl.prev()
<span class="code_keyword">if</span> (annotation.type === <span class="code_string">'comment'</span>) {
  readAnnotation(annotation.text)
}</code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code><a href="#childnode">ChildNode</a></code>. Previous node.
</p><h2 id="default-raw" class="doc_subtitle"><span class="doc_prefix">default#</span>raw()</h2><p>Returns a <code><a href="#node-raws">Node#raws</a></code> value. If the node is missing
the code style property (because the node was manually built or cloned),
PostCSS will try to autodetect the code style property by looking
at other nodes in the tree.</p>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(<span class="code_string">'a { background: white }'</span>)
root.nodes[<span class="code_number">0</span>].append({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> })
root.nodes[<span class="code_number">0</span>].nodes[<span class="code_number">1</span>].raws.before   <span class="code_comment">//=> undefined</span>
root.nodes[<span class="code_number">0</span>].nodes[<span class="code_number">1</span>].raw(<span class="code_string">'before'</span>) <span class="code_comment">//=> ' '</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>prop</code></td><td>string</td><td>Name of code style property.
</td></tr><tr><td><code>defaultType</code></td><td>string</td><td>Name of default value, it can be missed
if the value is the same as prop.
</td></tr></table><p>Returns <code>string</code>. Code style value.
</p><h2 id="default-remove" class="doc_subtitle"><span class="doc_prefix">default#</span>remove()</h2><p>Removes the node from its parent and cleans the parent properties
from the node and its children.</p>
<pre><code class="code"><span class="code_keyword">if</span> (decl.prop.match(<span class="code_regexp">/^-webkit-/</span>)) {
  decl.remove()
}</code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>default</code>. Node to make calls chain.
</p><h2 id="default-replacewith" class="doc_subtitle"><span class="doc_prefix">default#</span>replaceWith()</h2><p>Inserts node(s) before the current node and removes the current node.</p>
<pre><code class="code">AtRule: {
  <span class="code_attr">mixin</span>: <span class="code_function"><span class="code_params">atrule</span> =></span> {
    atrule.replaceWith(mixinRules[atrule.params])
  }
}</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td>(<a href="#atruleprops">AtRuleProps</a> | default | default | default | default | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | <a href="#childnode">ChildNode</a>[] | <a href="#childprops">ChildProps</a>[])[]</td><td>Mode(s) to replace current one.
</td></tr></table><p>Returns <code>default</code>. Current node to methods chain.
</p><h2 id="default-root" class="doc_subtitle"><span class="doc_prefix">default#</span>root()</h2><p>Finds the Root instance of the node’s tree.</p>
<pre><code class="code">root.nodes[<span class="code_number">0</span>].nodes[<span class="code_number">0</span>].root() === root</code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>default</code>. Root parent.
</p><h2 id="default-tojson" class="doc_subtitle"><span class="doc_prefix">default#</span>toJSON()</h2><p>Fix circular links on <code>JSON.stringify()</code>.</p>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>object</code>. Cleaned object.
</p><h2 id="default-tostring" class="doc_subtitle"><span class="doc_prefix">default#</span>toString()</h2><p>Returns a CSS string representing the node.</p>
<pre><code class="code"><span class="code_keyword">new</span> Rule({ <span class="code_attr">selector</span>: <span class="code_string">'a'</span> }).toString() <span class="code_comment">//=> "a {}"</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>stringifier</code></td><td><a href="#stringifier">Stringifier</a> | <a href="#syntax">Syntax</a></td><td>A syntax to use in string generation.
</td></tr></table><p>Returns <code>string</code>. CSS string of this node.
</p><h2 id="default-warn" class="doc_subtitle"><span class="doc_prefix">default#</span>warn()</h2><p>This method is provided as a convenience wrapper for <code><a href="#result-warn">Result#warn</a></code>.</p>
<pre><code class="code">  Declaration: {
    <span class="code_attr">bad</span>: <span class="code_function">(<span class="code_params">decl, { result }</span>) =></span> {
      decl.warn(result, <span class="code_string">'Deprecated property bad'</span>)
    }
  }</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>result</code></td><td>default</td><td>The <code><a href="#result">Result</a></code> instance that will receive the warning.
</td></tr><tr><td><code>text</code></td><td>string</td><td>Warning message.
</td></tr><tr><td><code>opts</code></td><td><a href="#warningoptions">WarningOptions</a></td><td>Warning Options.
</td></tr></table></section><section class="doc"><h1 id="default" class="doc_title">default</h1><p>Represents the source CSS.</p>
<pre><code class="code"><span class="code_keyword">const</span> root  = postcss.parse(css, { <span class="code_attr">from</span>: file })
<span class="code_keyword">const</span> input = root.source.input</code></pre>
<h2 id="default-css" class="doc_subtitle"><span class="doc_prefix">default#</span>css</h2><p>Input CSS source.</p>
<pre><code class="code"><span class="code_keyword">const</span> input = postcss.parse(<span class="code_string">'a{}'</span>, { <span class="code_attr">from</span>: file }).input
input.css <span class="code_comment">//=> "a{}"</span></code></pre>
<p>Type: string.</p><h2 id="default-file" class="doc_subtitle"><span class="doc_prefix">default#</span>file</h2><p>The absolute path to the CSS source file defined
with the <code>from</code> option.</p>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(css, { <span class="code_attr">from</span>: <span class="code_string">'a.css'</span> })
root.source.input.file <span class="code_comment">//=> '/home/ai/a.css'</span></code></pre>
<p>Type: string.</p><h2 id="default-hasbom" class="doc_subtitle"><span class="doc_prefix">default#</span>hasBOM</h2><p>The flag to indicate whether or not the source code has Unicode BOM.</p>
<p>Type: boolean.</p><h2 id="default-id" class="doc_subtitle"><span class="doc_prefix">default#</span>id</h2><p>The unique ID of the CSS source. It will be created if <code>from</code> option
is not provided (because PostCSS does not know the file path).</p>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(css)
root.source.input.file <span class="code_comment">//=> undefined</span>
root.source.input.id   <span class="code_comment">//=> "&#x3C;input css 8LZeVF>"</span></code></pre>
<p>Type: string.</p><h2 id="default-map" class="doc_subtitle"><span class="doc_prefix">default#</span>map</h2><p>The input source map passed from a compilation step before PostCSS
(for example, from Sass compiler).</p>
<pre><code class="code">root.source.input.map.consumer().sources <span class="code_comment">//=> ['a.sass']</span></code></pre>
<p>Type: default.</p><h2 id="default-from" class="doc_subtitle"><span class="doc_prefix">default#</span>from</h2><p>The CSS source identifier. Contains <code><a href="#input-file">Input#file</a></code> if the user
set the <code>from</code> option, or <code><a href="#input-id">Input#id</a></code> if they did not.</p>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(css, { <span class="code_attr">from</span>: <span class="code_string">'a.css'</span> })
root.source.input.from <span class="code_comment">//=> "/home/ai/a.css"</span>

<span class="code_keyword">const</span> root = postcss.parse(css)
root.source.input.from <span class="code_comment">//=> "&#x3C;input css 1>"</span></code></pre>
<h2 id="default-fromoffset" class="doc_subtitle"><span class="doc_prefix">default#</span>fromOffset()</h2><p>Converts source offset to line and column.</p>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>offset</code></td><td>number</td><td>Source offset.
</td></tr></table><p>Returns <code>{ col: number, line: number }</code>. </p><h2 id="default-origin" class="doc_subtitle"><span class="doc_prefix">default#</span>origin()</h2><p>Reads the input source map and returns a symbol position
in the input source (e.g., in a Sass file that was compiled
to CSS before being passed to PostCSS).</p>
<pre><code class="code">root.source.input.origin(<span class="code_number">1</span>, <span class="code_number">1</span>) <span class="code_comment">//=> { file: 'a.css', line: 3, column: 1 }</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>line</code></td><td>number</td><td>Line in input CSS.
</td></tr><tr><td><code>column</code></td><td>number</td><td>Column in input CSS.
</td></tr></table><p>Returns <code>false | <a href="#fileposition">FilePosition</a></code>. Position in input source.
</p></section><section class="doc"><h1 id="default" class="doc_title">default</h1><p>A Promise proxy for the result of PostCSS transformations.</p>
<p>A <code><a href="#lazyresult">LazyResult</a></code> instance is returned by <code>Processor#process</code>.</p>
<pre><code class="code"><span class="code_keyword">const</span> lazy = postcss([autoprefixer]).process(css)</code></pre>
<h2 id="default-catch" class="doc_subtitle"><span class="doc_prefix">default#</span>catch</h2><p>Processes input CSS through synchronous and asynchronous plugins
and calls onRejected for each error thrown in any plugin.</p>
<p>It implements standard Promise API.</p>
<pre><code class="code">postcss([autoprefixer]).process(css).then(<span class="code_function"><span class="code_params">result</span> =></span> {
  <span class="code_built_in">console</span>.log(result.css)
}).catch(<span class="code_function"><span class="code_params">error</span> =></span> {
  <span class="code_built_in">console</span>.error(error)
})</code></pre>
<p>Type: (onrejected: (reason: any) => TResult | PromiseLike&lt;TResult>) => Promise&lt;default | TResult>.</p><h2 id="default-finally" class="doc_subtitle"><span class="doc_prefix">default#</span>finally</h2><p>Processes input CSS through synchronous and asynchronous plugins
and calls onFinally on any error or when all plugins will finish work.</p>
<p>It implements standard Promise API.</p>
<pre><code class="code">postcss([autoprefixer]).process(css).finally(<span class="code_function">() =></span> {
  <span class="code_built_in">console</span>.log(<span class="code_string">'processing ended'</span>)
})</code></pre>
<p>Type: (onfinally: () => void) => Promise&lt;default>.</p><h2 id="default-then" class="doc_subtitle"><span class="doc_prefix">default#</span>then</h2><p>Processes input CSS through synchronous and asynchronous plugins
and calls <code>onFulfilled</code> with a Result instance. If a plugin throws
an error, the <code>onRejected</code> callback will be executed.</p>
<p>It implements standard Promise API.</p>
<pre><code class="code">postcss([autoprefixer]).process(css, { <span class="code_attr">from</span>: cssPath }).then(<span class="code_function"><span class="code_params">result</span> =></span> {
  <span class="code_built_in">console</span>.log(result.css)
})</code></pre>
<p>Type: (onfulfilled: (value: default) => TResult1 | PromiseLike&lt;TResult1>, onrejected: (reason: any) => TResult2 | PromiseLike&lt;TResult2>) => Promise&lt;TResult1 | TResult2>.</p><h2 id="default-[symbol.tostringtag]" class="doc_subtitle"><span class="doc_prefix">default#</span>[Symbol.toStringTag]</h2><p>Returns the default string description of an object.
Required to implement the Promise interface.</p>
<h2 id="default-content" class="doc_subtitle"><span class="doc_prefix">default#</span>content</h2><p>An alias for the <code>css</code> property. Use it with syntaxes
that generate non-CSS output.</p>
<p>This property will only work with synchronous plugins.
If the processor contains any asynchronous plugins
it will throw an error. This is why this method is only
for debug purpose, you should always use <code><a href="#lazyresult-then">LazyResult#then</a></code>.</p>
<h2 id="default-css" class="doc_subtitle"><span class="doc_prefix">default#</span>css</h2><p>Processes input CSS through synchronous plugins, converts <code><a href="#root">Root</a></code>
to a CSS string and returns <code><a href="#result-css">Result#css</a></code>.</p>
<p>This property will only work with synchronous plugins.
If the processor contains any asynchronous plugins
it will throw an error. This is why this method is only
for debug purpose, you should always use <code><a href="#lazyresult-then">LazyResult#then</a></code>.</p>
<h2 id="default-map" class="doc_subtitle"><span class="doc_prefix">default#</span>map</h2><p>Processes input CSS through synchronous plugins
and returns <code><a href="#result-map">Result#map</a></code>.</p>
<p>This property will only work with synchronous plugins.
If the processor contains any asynchronous plugins
it will throw an error. This is why this method is only
for debug purpose, you should always use <code><a href="#lazyresult-then">LazyResult#then</a></code>.</p>
<h2 id="default-messages" class="doc_subtitle"><span class="doc_prefix">default#</span>messages</h2><p>Processes input CSS through synchronous plugins
and returns <code><a href="#result-messages">Result#messages</a></code>.</p>
<p>This property will only work with synchronous plugins. If the processor
contains any asynchronous plugins it will throw an error.</p>
<p>This is why this method is only for debug purpose,
you should always use <code><a href="#lazyresult-then">LazyResult#then</a></code>.</p>
<h2 id="default-opts" class="doc_subtitle"><span class="doc_prefix">default#</span>opts</h2><p>Options from the <code>Processor#process</code> call.</p>
<h2 id="default-processor" class="doc_subtitle"><span class="doc_prefix">default#</span>processor</h2><p>Returns a <code>Processor</code> instance, which will be used
for CSS transformations.</p>
<h2 id="default-root" class="doc_subtitle"><span class="doc_prefix">default#</span>root</h2><p>Processes input CSS through synchronous plugins
and returns <code><a href="#result-root">Result#root</a></code>.</p>
<p>This property will only work with synchronous plugins. If the processor
contains any asynchronous plugins it will throw an error.</p>
<p>This is why this method is only for debug purpose,
you should always use <code><a href="#lazyresult-then">LazyResult#then</a></code>.</p>
<h2 id="default-async" class="doc_subtitle"><span class="doc_prefix">default#</span>async()</h2><p>Run plugin in async way and return <code><a href="#result">Result</a></code>.</p>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>Promise&lt;default></code>. Result with output content.
</p><h2 id="default-sync" class="doc_subtitle"><span class="doc_prefix">default#</span>sync()</h2><p>Run plugin in sync way and return <code><a href="#result">Result</a></code>.</p>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>default</code>. Result with output content.
</p><h2 id="default-tostring" class="doc_subtitle"><span class="doc_prefix">default#</span>toString()</h2><p>Alias for the <code><a href="#lazyresult-css">LazyResult#css</a></code> property.</p>
<pre><code class="code">lazy + <span class="code_string">''</span> === lazy.css</code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>string</code>. Output CSS.
</p><h2 id="default-warnings" class="doc_subtitle"><span class="doc_prefix">default#</span>warnings()</h2><p>Processes input CSS through synchronous plugins
and calls <code><a href="#result-warnings">Result#warnings</a></code>.</p>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>default[]</code>. Warnings from plugins.
</p></section><section class="doc"><h1 id="default" class="doc_title">default</h1><p>All node classes inherit the following common methods.</p>
<p>You should not extend this classes to create AST for selector or value
parser.</p>
<h2 id="default-parent" class="doc_subtitle"><span class="doc_prefix">default#</span>parent</h2><p>The node’s parent node.</p>
<pre><code class="code">root.nodes[<span class="code_number">0</span>].parent === root</code></pre>
<p>Type: default.</p><h2 id="default-raws" class="doc_subtitle"><span class="doc_prefix">default#</span>raws</h2><p>Information to generate byte-to-byte equal node string as it was
in the origin input.</p>
<p>Every parser saves its own properties,
but the default CSS parser uses:</p>
<ul>
<li><code>before</code>: the space symbols before the node. It also stores <code>*</code>
and <code>_</code> symbols before the declaration (IE hack).</li>
<li><code>after</code>: the space symbols after the last child of the node
to the end of the node.</li>
<li><code>between</code>: the symbols between the property and value
for declarations, selector and <code>{</code> for rules, or last parameter
and <code>{</code> for at-rules.</li>
<li><code>semicolon</code>: contains true if the last child has
an (optional) semicolon.</li>
<li><code>afterName</code>: the space between the at-rule name and its parameters.</li>
<li><code>left</code>: the space symbols between <code>/*</code> and the comment’s text.</li>
<li><code>right</code>: the space symbols between the comment’s text
and <code>*/</code>.</li>
<li><code>important</code>: the content of the important statement,
if it is not just <code>!important</code>.</li>
</ul>
<p>PostCSS cleans selectors, declaration values and at-rule parameters
from comments and extra spaces, but it stores origin content in raws
properties. As such, if you don’t change a declaration’s value,
PostCSS will use the raw value with comments.</p>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(<span class="code_string">'a {\n  color:black\n}'</span>)
root.first.first.raws <span class="code_comment">//=> { before: '\n  ', between: ':' }</span></code></pre>
<p>Type: any.</p><h2 id="default-source" class="doc_subtitle"><span class="doc_prefix">default#</span>source</h2><p>The input source of the node.</p>
<p>The property is used in source map generation.</p>
<p>If you create a node manually (e.g., with <code>postcss.decl()</code>),
that node will not have a <code>source</code> property and will be absent
from the source map. For this reason, the plugin developer should
consider cloning nodes to create new ones (in which case the new node’s
source will reference the original, cloned node) or setting
the <code>source</code> property manually.</p>
<pre><code class="code">decl.source.input.from <span class="code_comment">//=> '/home/ai/a.sass'</span>
decl.source.start      <span class="code_comment">//=> { line: 10, column: 2 }</span>
decl.source.end        <span class="code_comment">//=> { line: 10, column: 12 }</span></code></pre>
<pre><code class="code"><span class="code_comment">// Bad</span>
<span class="code_keyword">const</span> prefixed = postcss.decl({
  <span class="code_attr">prop</span>: <span class="code_string">'-moz-'</span> + decl.prop,
  <span class="code_attr">value</span>: decl.value
})

<span class="code_comment">// Good</span>
<span class="code_keyword">const</span> prefixed = decl.clone({ <span class="code_attr">prop</span>: <span class="code_string">'-moz-'</span> + decl.prop })</code></pre>
<pre><code class="code"><span class="code_keyword">if</span> (atrule.name === <span class="code_string">'add-link'</span>) {
  <span class="code_keyword">const</span> rule = postcss.rule({ <span class="code_attr">selector</span>: <span class="code_string">'a'</span>, <span class="code_attr">source</span>: atrule.source })
  atrule.parent.insertBefore(atrule, rule)
}</code></pre>
<p>Type: <a href="#source">Source</a>.</p><h2 id="default-type" class="doc_subtitle"><span class="doc_prefix">default#</span>type</h2><p>tring representing the node’s type. Possible values are <code>root</code>, <code>atrule</code>,
<code>rule</code>, <code>decl</code>, or <code>comment</code>.</p>
<pre><code class="code"><span class="code_keyword">new</span> Declaration({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> }).type <span class="code_comment">//=> 'decl'</span></code></pre>
<p>Type: string.</p><h2 id="default-after" class="doc_subtitle"><span class="doc_prefix">default#</span>after()</h2><p>Insert new node after current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertAfter(node, add)</code>.</p>
<pre><code class="code">decl.after(<span class="code_string">'color: black'</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#atruleprops">AtRuleProps</a> | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | default | default[]</td><td>New node.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-before" class="doc_subtitle"><span class="doc_prefix">default#</span>before()</h2><p>Insert new node before current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertBefore(node, add)</code>.</p>
<pre><code class="code">decl.before(<span class="code_string">'content: ""'</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#atruleprops">AtRuleProps</a> | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | default | default[]</td><td>New node.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-cleanraws" class="doc_subtitle"><span class="doc_prefix">default#</span>cleanRaws()</h2><p>Clear the code style properties for the node and its children.</p>
<pre><code class="code">node.raws.before  <span class="code_comment">//=> ' '</span>
node.cleanRaws()
node.raws.before  <span class="code_comment">//=> undefined</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>keepBetween</code></td><td>boolean</td><td>Keep the <code>raws.between</code> symbols.
</td></tr></table><h2 id="default-clone" class="doc_subtitle"><span class="doc_prefix">default#</span>clone()</h2><p>Returns an exact clone of the node.</p>
<p>The resulting cloned node and its (cloned) children will retain
code style properties.</p>
<pre><code class="code">decl.raws.before    <span class="code_comment">//=> "\n  "</span>
<span class="code_keyword">const</span> cloned = decl.clone({ <span class="code_attr">prop</span>: <span class="code_string">'-moz-'</span> + decl.prop })
cloned.raws.before  <span class="code_comment">//=> "\n  "</span>
cloned.toString()   <span class="code_comment">//=> -moz-transform: scale(0)</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>object</td><td>New properties to override in the clone.
</td></tr></table><p>Returns <code>default</code>. Clone of the node.
</p><h2 id="default-cloneafter" class="doc_subtitle"><span class="doc_prefix">default#</span>cloneAfter()</h2><p>Shortcut to clone the node and insert the resulting cloned node
after the current node.</p>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>object</td><td>New properties to override in the clone.
</td></tr></table><p>Returns <code>default</code>. New node.
</p><h2 id="default-clonebefore" class="doc_subtitle"><span class="doc_prefix">default#</span>cloneBefore()</h2><p>Shortcut to clone the node and insert the resulting cloned node
before the current node.</p>
<pre><code class="code">decl.cloneBefore({ <span class="code_attr">prop</span>: <span class="code_string">'-moz-'</span> + decl.prop })</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>object</td><td>Mew properties to override in the clone.
</td></tr></table><p>Returns <code>default</code>. New node
</p><h2 id="default-error" class="doc_subtitle"><span class="doc_prefix">default#</span>error()</h2><p>Returns a <code><a href="#csssyntaxerror">CssSyntaxError</a></code> instance containing the original position
of the node in the source, showing line and column numbers and also
a small excerpt to facilitate debugging.</p>
<p>If present, an input source map will be used to get the original position
of the source, even from a previous compilation step
(e.g., from Sass compilation).</p>
<p>This method produces very useful error messages.</p>
<pre><code class="code"><span class="code_keyword">if</span> (!variables[name]) {
  <span class="code_keyword">throw</span> decl.error(<span class="code_string">`Unknown variable <span class="code_subst">${name}</span>`</span>, { <span class="code_attr">word</span>: name })
  <span class="code_comment">// CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black</span>
  <span class="code_comment">//   color: $black</span>
  <span class="code_comment">// a</span>
  <span class="code_comment">//          ^</span>
  <span class="code_comment">//   background: white</span>
}</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>message</code></td><td>string</td><td>Error description.
</td></tr><tr><td><code>options</code></td><td><a href="#nodeerroroptions">NodeErrorOptions</a></td><td></td></tr></table><p>Returns <code>default</code>. Error object to throw it.
</p><h2 id="default-next" class="doc_subtitle"><span class="doc_prefix">default#</span>next()</h2><p>Returns the next child of the node’s parent.
Returns <code>undefined</code> if the current node is the last child.</p>
<pre><code class="code"><span class="code_keyword">if</span> (comment.text === <span class="code_string">'delete next'</span>) {
  <span class="code_keyword">const</span> next = comment.next()
  <span class="code_keyword">if</span> (next) {
    next.remove()
  }
}</code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code><a href="#childnode">ChildNode</a></code>. Next node.
</p><h2 id="default-positioninside" class="doc_subtitle"><span class="doc_prefix">default#</span>positionInside()</h2><p>Convert string index to line/column.</p>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>number</td><td>The symbol number in the node’s string.
</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. Symbol position in file.
</p><h2 id="default-prev" class="doc_subtitle"><span class="doc_prefix">default#</span>prev()</h2><p>Returns the previous child of the node’s parent.
Returns <code>undefined</code> if the current node is the first child.</p>
<pre><code class="code"><span class="code_keyword">const</span> annotation = decl.prev()
<span class="code_keyword">if</span> (annotation.type === <span class="code_string">'comment'</span>) {
  readAnnotation(annotation.text)
}</code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code><a href="#childnode">ChildNode</a></code>. Previous node.
</p><h2 id="default-raw" class="doc_subtitle"><span class="doc_prefix">default#</span>raw()</h2><p>Returns a <code><a href="#node-raws">Node#raws</a></code> value. If the node is missing
the code style property (because the node was manually built or cloned),
PostCSS will try to autodetect the code style property by looking
at other nodes in the tree.</p>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(<span class="code_string">'a { background: white }'</span>)
root.nodes[<span class="code_number">0</span>].append({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> })
root.nodes[<span class="code_number">0</span>].nodes[<span class="code_number">1</span>].raws.before   <span class="code_comment">//=> undefined</span>
root.nodes[<span class="code_number">0</span>].nodes[<span class="code_number">1</span>].raw(<span class="code_string">'before'</span>) <span class="code_comment">//=> ' '</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>prop</code></td><td>string</td><td>Name of code style property.
</td></tr><tr><td><code>defaultType</code></td><td>string</td><td>Name of default value, it can be missed
if the value is the same as prop.
</td></tr></table><p>Returns <code>string</code>. Code style value.
</p><h2 id="default-remove" class="doc_subtitle"><span class="doc_prefix">default#</span>remove()</h2><p>Removes the node from its parent and cleans the parent properties
from the node and its children.</p>
<pre><code class="code"><span class="code_keyword">if</span> (decl.prop.match(<span class="code_regexp">/^-webkit-/</span>)) {
  decl.remove()
}</code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>default</code>. Node to make calls chain.
</p><h2 id="default-replacewith" class="doc_subtitle"><span class="doc_prefix">default#</span>replaceWith()</h2><p>Inserts node(s) before the current node and removes the current node.</p>
<pre><code class="code">AtRule: {
  <span class="code_attr">mixin</span>: <span class="code_function"><span class="code_params">atrule</span> =></span> {
    atrule.replaceWith(mixinRules[atrule.params])
  }
}</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td>(<a href="#atruleprops">AtRuleProps</a> | default | default | default | default | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | <a href="#childnode">ChildNode</a>[] | <a href="#childprops">ChildProps</a>[])[]</td><td>Mode(s) to replace current one.
</td></tr></table><p>Returns <code>default</code>. Current node to methods chain.
</p><h2 id="default-root" class="doc_subtitle"><span class="doc_prefix">default#</span>root()</h2><p>Finds the Root instance of the node’s tree.</p>
<pre><code class="code">root.nodes[<span class="code_number">0</span>].nodes[<span class="code_number">0</span>].root() === root</code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>default</code>. Root parent.
</p><h2 id="default-tojson" class="doc_subtitle"><span class="doc_prefix">default#</span>toJSON()</h2><p>Fix circular links on <code>JSON.stringify()</code>.</p>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>object</code>. Cleaned object.
</p><h2 id="default-tostring" class="doc_subtitle"><span class="doc_prefix">default#</span>toString()</h2><p>Returns a CSS string representing the node.</p>
<pre><code class="code"><span class="code_keyword">new</span> Rule({ <span class="code_attr">selector</span>: <span class="code_string">'a'</span> }).toString() <span class="code_comment">//=> "a {}"</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>stringifier</code></td><td><a href="#stringifier">Stringifier</a> | <a href="#syntax">Syntax</a></td><td>A syntax to use in string generation.
</td></tr></table><p>Returns <code>string</code>. CSS string of this node.
</p><h2 id="default-warn" class="doc_subtitle"><span class="doc_prefix">default#</span>warn()</h2><p>This method is provided as a convenience wrapper for <code><a href="#result-warn">Result#warn</a></code>.</p>
<pre><code class="code">  Declaration: {
    <span class="code_attr">bad</span>: <span class="code_function">(<span class="code_params">decl, { result }</span>) =></span> {
      decl.warn(result, <span class="code_string">'Deprecated property bad'</span>)
    }
  }</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>result</code></td><td>default</td><td>The <code><a href="#result">Result</a></code> instance that will receive the warning.
</td></tr><tr><td><code>text</code></td><td>string</td><td>Warning message.
</td></tr><tr><td><code>opts</code></td><td><a href="#warningoptions">WarningOptions</a></td><td>Warning Options.
</td></tr></table></section><section class="doc"><h1 id="default" class="doc_title">default</h1><p>Source map information from input CSS.
For example, source map after Sass compiler.</p>
<p>This class will automatically find source map in input CSS or in file system
near input file (according <code>from</code> option).</p>
<pre><code class="code"><span class="code_keyword">const</span> root = parse(css, { <span class="code_attr">from</span>: <span class="code_string">'a.sass.css'</span> })
root.input.map <span class="code_comment">//=> PreviousMap</span></code></pre>
<h2 id="default-annotation" class="doc_subtitle"><span class="doc_prefix">default#</span>annotation</h2><p><code>sourceMappingURL</code> content.</p>
<p>Type: string.</p><h2 id="default-file" class="doc_subtitle"><span class="doc_prefix">default#</span>file</h2><p>The CSS source identifier. Contains <code><a href="#input-file">Input#file</a></code> if the user
set the <code>from</code> option, or <code><a href="#input-id">Input#id</a></code> if they did not.</p>
<p>Type: string.</p><h2 id="default-inline" class="doc_subtitle"><span class="doc_prefix">default#</span>inline</h2><p>Was source map inlined by data-uri to input CSS.</p>
<p>Type: boolean.</p><h2 id="default-mapfile" class="doc_subtitle"><span class="doc_prefix">default#</span>mapFile</h2><p>Path to source map file.</p>
<p>Type: string.</p><h2 id="default-root" class="doc_subtitle"><span class="doc_prefix">default#</span>root</h2><p>The directory with source map file, if source map is in separated file.</p>
<p>Type: string.</p><h2 id="default-text" class="doc_subtitle"><span class="doc_prefix">default#</span>text</h2><p>Source map file content.</p>
<p>Type: string.</p><h2 id="default-consumer" class="doc_subtitle"><span class="doc_prefix">default#</span>consumer()</h2><p>Create a instance of <code>SourceMapGenerator</code> class
from the <code>source-map</code> library to work with source map information.</p>
<p>It is lazy method, so it will create object only on first call
and then it will use cache.</p>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>SourceMapConsumer</code>. Object with source map information.
</p><h2 id="default-withcontent" class="doc_subtitle"><span class="doc_prefix">default#</span>withContent()</h2><p>Does source map contains <code>sourcesContent</code> with input source text.</p>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>boolean</code>. Is <code>sourcesContent</code> present.
</p></section><section class="doc"><h1 id="default" class="doc_title">default</h1><p>Contains plugins to process CSS. Create one <code>Processor</code> instance,
initialize its plugins, and then use that instance on numerous CSS files.</p>
<pre><code class="code"><span class="code_keyword">const</span> processor = postcss([autoprefixer, precss])
processor.process(css1).then(<span class="code_function"><span class="code_params">result</span> =></span> <span class="code_built_in">console</span>.log(result.css))
processor.process(css2).then(<span class="code_function"><span class="code_params">result</span> =></span> <span class="code_built_in">console</span>.log(result.css))</code></pre>
<h2 id="default-plugins" class="doc_subtitle"><span class="doc_prefix">default#</span>plugins</h2><p>Plugins added to this processor.</p>
<pre><code class="code"><span class="code_keyword">const</span> processor = postcss([autoprefixer, precss])
processor.plugins.length <span class="code_comment">//=> 2</span></code></pre>
<p>Type: (<a href="#plugin">Plugin</a> | <a href="#transformer">Transformer</a> | <a href="#transformcallback">TransformCallback</a>)[].</p><h2 id="default-version" class="doc_subtitle"><span class="doc_prefix">default#</span>version</h2><p>Current PostCSS version.</p>
<pre><code class="code"><span class="code_keyword">if</span> (result.processor.version.split(<span class="code_string">'.'</span>)[<span class="code_number">0</span>] !== <span class="code_string">'6'</span>) {
  <span class="code_keyword">throw</span> <span class="code_keyword">new</span> <span class="code_built_in">Error</span>(<span class="code_string">'This plugin works only with PostCSS 6'</span>)
}</code></pre>
<p>Type: string.</p><h2 id="default-process" class="doc_subtitle"><span class="doc_prefix">default#</span>process()</h2><p>Parses source CSS and returns a <code><a href="#lazyresult">LazyResult</a></code> Promise proxy.
Because some plugins can be asynchronous it doesn’t make
any transformations. Transformations will be applied
in the <code><a href="#lazyresult">LazyResult</a></code> methods.</p>
<pre><code class="code">processor.process(css, { <span class="code_attr">from</span>: <span class="code_string">'a.css'</span>, <span class="code_attr">to</span>: <span class="code_string">'a.out.css'</span> })
  .then(<span class="code_function"><span class="code_params">result</span> =></span> {
     <span class="code_built_in">console</span>.log(result.css)
  })</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>css</code></td><td>string | default | default | default | { toString: () => string }</td><td>String with input CSS or any object with a <code>toString()</code> method,
like a Buffer. Optionally, senda <code><a href="#result">Result</a></code> instance
and the processor will take the <code><a href="#root">Root</a></code> from it.
</td></tr><tr><td><code>options</code></td><td><a href="#processoptions">ProcessOptions</a></td><td></td></tr></table><p>Returns <code>default</code>. Promise proxy.
</p><h2 id="default-use" class="doc_subtitle"><span class="doc_prefix">default#</span>use()</h2><p>Adds a plugin to be used as a CSS processor.</p>
<p>PostCSS plugin can be in 4 formats:</p>
<ul>
<li>A plugin in <code><a href="#plugin">Plugin</a></code> format.</li>
<li>A plugin creator function with <code>pluginCreator.postcss = true</code>.
PostCSS will call this function without argument to get plugin.</li>
<li>A function. PostCSS will pass the function a @{link Root}
as the first argument and current <code><a href="#result">Result</a></code> instance
as the second.</li>
<li>Another <code>Processor</code> instance. PostCSS will copy plugins
from that instance into this one.</li>
</ul>
<p>Plugins can also be added by passing them as arguments when creating
a <code>postcss</code> instance (see [<code>postcss(plugins)</code>]).</p>
<p>Asynchronous plugins should return a <code>Promise</code> instance.</p>
<pre><code class="code"><span class="code_keyword">const</span> processor = postcss()
  .use(autoprefixer)
  .use(precss)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>plugin</code></td><td><a href="#acceptedplugin">AcceptedPlugin</a></td><td>PostCSS plugin or <code>Processor</code> with plugins.
</td></tr></table><p>Returns <code>default</code>. Current processor to make methods chain.
</p></section><section class="doc"><h1 id="default" class="doc_title">default</h1><p>Provides the result of the PostCSS transformations.</p>
<p>A Result instance is returned by <code><a href="#lazyresult-then">LazyResult#then</a></code>
or <code><a href="#root-toresult">Root#toResult</a></code> methods.</p>
<pre><code class="code">postcss([autoprefixer]).process(css).then(<span class="code_function"><span class="code_params">result</span> =></span> {
 <span class="code_built_in">console</span>.log(result.css)
})</code></pre>
<pre><code class="code"><span class="code_keyword">const</span> result2 = postcss.parse(css).toResult()</code></pre>
<h2 id="default-css" class="doc_subtitle"><span class="doc_prefix">default#</span>css</h2><p>A CSS string representing of <code><a href="#result-root">Result#root</a></code>.</p>
<pre><code class="code">postcss.parse(<span class="code_string">'a{}'</span>).toResult().css <span class="code_comment">//=> "a{}"</span></code></pre>
<p>Type: string.</p><h2 id="default-lastplugin" class="doc_subtitle"><span class="doc_prefix">default#</span>lastPlugin</h2><p>Last runned PostCSS plugin.</p>
<p>Type: <a href="#plugin">Plugin</a> | <a href="#transformcallback">TransformCallback</a>.</p><h2 id="default-map" class="doc_subtitle"><span class="doc_prefix">default#</span>map</h2><p>An instance of <code>SourceMapGenerator</code> class from the <code>source-map</code> library,
representing changes to the <code><a href="#result-root">Result#root</a></code> instance.</p>
<pre><code class="code">result.map.toJSON() <span class="code_comment">//=> { version: 3, file: 'a.css', … }</span></code></pre>
<pre><code class="code"><span class="code_keyword">if</span> (result.map) {
  fs.writeFileSync(result.opts.to + <span class="code_string">'.map'</span>, result.map.toString())
}</code></pre>
<p>Type: <a href="#sourcemap">SourceMap</a>.</p><h2 id="default-messages" class="doc_subtitle"><span class="doc_prefix">default#</span>messages</h2><p>Contains messages from plugins (e.g., warnings or custom messages).
Each message should have type and plugin properties.</p>
<pre><code class="code">AtRule: {
  <span class="code_attr">import</span>: (atRule, { result }) {
    <span class="code_keyword">const</span> importedFile = parseImport(atRule)
    result.messages.push({
      <span class="code_attr">type</span>: <span class="code_string">'dependency'</span>,
      <span class="code_attr">plugin</span>: <span class="code_string">'postcss-import'</span>,
      <span class="code_attr">file</span>: importedFile,
      <span class="code_attr">parent</span>: result.opts.from
    })
  }
}</code></pre>
<p>Type: <a href="#message">Message</a>[].</p><h2 id="default-opts" class="doc_subtitle"><span class="doc_prefix">default#</span>opts</h2><p>Options from the <code>Processor#process</code> or <code><a href="#root-toresult">Root#toResult</a></code> call
that produced this Result instance.]</p>
<pre><code class="code">root.toResult(opts).opts === opts</code></pre>
<p>Type: <a href="#resultoptions">ResultOptions</a>.</p><h2 id="default-processor" class="doc_subtitle"><span class="doc_prefix">default#</span>processor</h2><p>The Processor instance used for this transformation.</p>
<pre><code class="code"><span class="code_keyword">for</span> (<span class="code_keyword">const</span> plugin <span class="code_keyword">of</span> result.processor.plugins) {
  <span class="code_keyword">if</span> (plugin.postcssPlugin === <span class="code_string">'postcss-bad'</span>) {
    <span class="code_keyword">throw</span> <span class="code_string">'postcss-good is incompatible with postcss-bad'</span>
  }
})</code></pre>
<p>Type: default.</p><h2 id="default-root" class="doc_subtitle"><span class="doc_prefix">default#</span>root</h2><p>Root node after all transformations.</p>
<pre><code class="code">root.toResult().root === root</code></pre>
<p>Type: default.</p><h2 id="default-content" class="doc_subtitle"><span class="doc_prefix">default#</span>content</h2><p>An alias for the <code><a href="#result-css">Result#css</a></code> property.
Use it with syntaxes that generate non-CSS output.</p>
<pre><code class="code">result.css === result.content</code></pre>
<h2 id="default-tostring" class="doc_subtitle"><span class="doc_prefix">default#</span>toString()</h2><p>Returns for <code><a href="#result-css">Result#css</a></code> content.</p>
<pre><code class="code">result + <span class="code_string">''</span> === result.css</code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>string</code>. String representing of <code><a href="#result-root">Result#root</a></code>.
</p><h2 id="default-warn" class="doc_subtitle"><span class="doc_prefix">default#</span>warn()</h2><p>Creates an instance of <code><a href="#warning">Warning</a></code> and adds it to <code><a href="#result-messages">Result#messages</a></code>.</p>
<pre><code class="code"><span class="code_keyword">if</span> (decl.important) {
  result.warn(<span class="code_string">'Avoid !important'</span>, { <span class="code_attr">node</span>: decl, <span class="code_attr">word</span>: <span class="code_string">'!important'</span> })
}</code></pre>
<table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>message</code></td><td>string</td></tr><tr><td><code>options</code></td><td><a href="#warningoptions">WarningOptions</a></td></tr></table><p>Returns <code>default</code>. Created warning.
</p><h2 id="default-warnings" class="doc_subtitle"><span class="doc_prefix">default#</span>warnings()</h2><p>Returns warnings from plugins. Filters <code><a href="#warning">Warning</a></code> instances
from <code><a href="#result-messages">Result#messages</a></code>.</p>
<pre><code class="code">result.warnings().forEach(<span class="code_function"><span class="code_params">warn</span> =></span> {
  <span class="code_built_in">console</span>.warn(warn.toString())
})</code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>default[]</code>. Warnings from plugins.
</p></section><section class="doc"><h1 id="default" class="doc_title">default</h1><p>Represents a CSS file and contains all its parsed nodes.</p>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(<span class="code_string">'a{color:black} b{z-index:2}'</span>)
root.type         <span class="code_comment">//=> 'root'</span>
root.nodes.length <span class="code_comment">//=> 2</span></code></pre>
<h2 id="default-nodes" class="doc_subtitle"><span class="doc_prefix">default#</span>nodes</h2><p>An array containing the container’s children.</p>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(<span class="code_string">'a { color: black }'</span>)
root.nodes.length           <span class="code_comment">//=> 1</span>
root.nodes[<span class="code_number">0</span>].selector      <span class="code_comment">//=> 'a'</span>
root.nodes[<span class="code_number">0</span>].nodes[<span class="code_number">0</span>].prop <span class="code_comment">//=> 'color'</span></code></pre>
<p>Type: <a href="#childnode">ChildNode</a>[].</p><h2 id="default-parent" class="doc_subtitle"><span class="doc_prefix">default#</span>parent</h2><p>The node’s parent node.</p>
<pre><code class="code">root.nodes[<span class="code_number">0</span>].parent === root</code></pre>
<p>Type: undefined.</p><h2 id="default-raws" class="doc_subtitle"><span class="doc_prefix">default#</span>raws</h2><p>Information to generate byte-to-byte equal node string as it was
in the origin input.</p>
<p>Every parser saves its own properties,
but the default CSS parser uses:</p>
<ul>
<li><code>before</code>: the space symbols before the node. It also stores <code>*</code>
and <code>_</code> symbols before the declaration (IE hack).</li>
<li><code>after</code>: the space symbols after the last child of the node
to the end of the node.</li>
<li><code>between</code>: the symbols between the property and value
for declarations, selector and <code>{</code> for rules, or last parameter
and <code>{</code> for at-rules.</li>
<li><code>semicolon</code>: contains true if the last child has
an (optional) semicolon.</li>
<li><code>afterName</code>: the space between the at-rule name and its parameters.</li>
<li><code>left</code>: the space symbols between <code>/*</code> and the comment’s text.</li>
<li><code>right</code>: the space symbols between the comment’s text
and <code>*/</code>.</li>
<li><code>important</code>: the content of the important statement,
if it is not just <code>!important</code>.</li>
</ul>
<p>PostCSS cleans selectors, declaration values and at-rule parameters
from comments and extra spaces, but it stores origin content in raws
properties. As such, if you don’t change a declaration’s value,
PostCSS will use the raw value with comments.</p>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(<span class="code_string">'a {\n  color:black\n}'</span>)
root.first.first.raws <span class="code_comment">//=> { before: '\n  ', between: ':' }</span></code></pre>
<p>Type: <a href="#rootraws">RootRaws</a>.</p><h2 id="default-source" class="doc_subtitle"><span class="doc_prefix">default#</span>source</h2><p>The input source of the node.</p>
<p>The property is used in source map generation.</p>
<p>If you create a node manually (e.g., with <code>postcss.decl()</code>),
that node will not have a <code>source</code> property and will be absent
from the source map. For this reason, the plugin developer should
consider cloning nodes to create new ones (in which case the new node’s
source will reference the original, cloned node) or setting
the <code>source</code> property manually.</p>
<pre><code class="code">decl.source.input.from <span class="code_comment">//=> '/home/ai/a.sass'</span>
decl.source.start      <span class="code_comment">//=> { line: 10, column: 2 }</span>
decl.source.end        <span class="code_comment">//=> { line: 10, column: 12 }</span></code></pre>
<pre><code class="code"><span class="code_comment">// Bad</span>
<span class="code_keyword">const</span> prefixed = postcss.decl({
  <span class="code_attr">prop</span>: <span class="code_string">'-moz-'</span> + decl.prop,
  <span class="code_attr">value</span>: decl.value
})

<span class="code_comment">// Good</span>
<span class="code_keyword">const</span> prefixed = decl.clone({ <span class="code_attr">prop</span>: <span class="code_string">'-moz-'</span> + decl.prop })</code></pre>
<pre><code class="code"><span class="code_keyword">if</span> (atrule.name === <span class="code_string">'add-link'</span>) {
  <span class="code_keyword">const</span> rule = postcss.rule({ <span class="code_attr">selector</span>: <span class="code_string">'a'</span>, <span class="code_attr">source</span>: atrule.source })
  atrule.parent.insertBefore(atrule, rule)
}</code></pre>
<p>Type: <a href="#source">Source</a>.</p><h2 id="default-type" class="doc_subtitle"><span class="doc_prefix">default#</span>type</h2><p>tring representing the node’s type. Possible values are <code>root</code>, <code>atrule</code>,
<code>rule</code>, <code>decl</code>, or <code>comment</code>.</p>
<pre><code class="code"><span class="code_keyword">new</span> Declaration({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> }).type <span class="code_comment">//=> 'decl'</span></code></pre>
<p>Type: "root".</p><h2 id="default-first" class="doc_subtitle"><span class="doc_prefix">default#</span>first</h2><p>The container’s first child.</p>
<pre><code class="code">rule.first === rules.nodes[<span class="code_number">0</span>]</code></pre>
<h2 id="default-last" class="doc_subtitle"><span class="doc_prefix">default#</span>last</h2><p>The container’s last child.</p>
<pre><code class="code">rule.last === rule.nodes[rule.nodes.length - <span class="code_number">1</span>]</code></pre>
<h2 id="default-after" class="doc_subtitle"><span class="doc_prefix">default#</span>after()</h2><p>Insert new node after current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertAfter(node, add)</code>.</p>
<pre><code class="code">decl.after(<span class="code_string">'color: black'</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#atruleprops">AtRuleProps</a> | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | default | default[]</td><td>New node.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-append" class="doc_subtitle"><span class="doc_prefix">default#</span>append()</h2><p>Inserts new nodes to the end of the container.</p>
<pre><code class="code"><span class="code_keyword">const</span> decl1 = <span class="code_keyword">new</span> Declaration({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> })
<span class="code_keyword">const</span> decl2 = <span class="code_keyword">new</span> Declaration({ <span class="code_attr">prop</span>: <span class="code_string">'background-color'</span>, <span class="code_attr">value</span>: <span class="code_string">'white'</span> })
rule.append(decl1, decl2)

root.append({ <span class="code_attr">name</span>: <span class="code_string">'charset'</span>, <span class="code_attr">params</span>: <span class="code_string">'"UTF-8"'</span> })  <span class="code_comment">// at-rule</span>
root.append({ <span class="code_attr">selector</span>: <span class="code_string">'a'</span> })                       <span class="code_comment">// rule</span>
rule.append({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> })       <span class="code_comment">// declaration</span>
rule.append({ <span class="code_attr">text</span>: <span class="code_string">'Comment'</span> })                     <span class="code_comment">// comment</span>

root.append(<span class="code_string">'a {}'</span>)
root.first.append(<span class="code_string">'color: black; z-index: 1'</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td>(string | <a href="#atruleprops">AtRuleProps</a> | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | default | default[] | <a href="#childprops">ChildProps</a>[] | string[])[]</td><td>New nodes.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-before" class="doc_subtitle"><span class="doc_prefix">default#</span>before()</h2><p>Insert new node before current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertBefore(node, add)</code>.</p>
<pre><code class="code">decl.before(<span class="code_string">'content: ""'</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#atruleprops">AtRuleProps</a> | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | default | default[]</td><td>New node.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-cleanraws" class="doc_subtitle"><span class="doc_prefix">default#</span>cleanRaws()</h2><p>Clear the code style properties for the node and its children.</p>
<pre><code class="code">node.raws.before  <span class="code_comment">//=> ' '</span>
node.cleanRaws()
node.raws.before  <span class="code_comment">//=> undefined</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>keepBetween</code></td><td>boolean</td><td>Keep the <code>raws.between</code> symbols.
</td></tr></table><h2 id="default-clone" class="doc_subtitle"><span class="doc_prefix">default#</span>clone()</h2><p>Returns an exact clone of the node.</p>
<p>The resulting cloned node and its (cloned) children will retain
code style properties.</p>
<pre><code class="code">decl.raws.before    <span class="code_comment">//=> "\n  "</span>
<span class="code_keyword">const</span> cloned = decl.clone({ <span class="code_attr">prop</span>: <span class="code_string">'-moz-'</span> + decl.prop })
cloned.raws.before  <span class="code_comment">//=> "\n  "</span>
cloned.toString()   <span class="code_comment">//=> -moz-transform: scale(0)</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>object</td><td>New properties to override in the clone.
</td></tr></table><p>Returns <code>default</code>. Clone of the node.
</p><h2 id="default-cloneafter" class="doc_subtitle"><span class="doc_prefix">default#</span>cloneAfter()</h2><p>Shortcut to clone the node and insert the resulting cloned node
after the current node.</p>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>object</td><td>New properties to override in the clone.
</td></tr></table><p>Returns <code>default</code>. New node.
</p><h2 id="default-clonebefore" class="doc_subtitle"><span class="doc_prefix">default#</span>cloneBefore()</h2><p>Shortcut to clone the node and insert the resulting cloned node
before the current node.</p>
<pre><code class="code">decl.cloneBefore({ <span class="code_attr">prop</span>: <span class="code_string">'-moz-'</span> + decl.prop })</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>object</td><td>Mew properties to override in the clone.
</td></tr></table><p>Returns <code>default</code>. New node
</p><h2 id="default-each" class="doc_subtitle"><span class="doc_prefix">default#</span>each()</h2><p>Iterates through the container’s immediate children,
calling <code>callback</code> for each child.</p>
<p>Returning <code>false</code> in the callback will break iteration.</p>
<p>This method only iterates through the container’s immediate children.
If you need to recursively iterate through all the container’s descendant
nodes, use <code><a href="#container-walk">Container#walk</a></code>.</p>
<p>Unlike the for <code>{}</code>-cycle or <code>Array#forEach</code> this iterator is safe
if you are mutating the array of child nodes during iteration.
PostCSS will adjust the current index to match the mutations.</p>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(<span class="code_string">'a { color: black; z-index: 1 }'</span>)
<span class="code_keyword">const</span> rule = root.first

<span class="code_keyword">for</span> (<span class="code_keyword">const</span> decl <span class="code_keyword">of</span> rule.nodes) {
  decl.cloneBefore({ <span class="code_attr">prop</span>: <span class="code_string">'-webkit-'</span> + decl.prop })
  <span class="code_comment">// Cycle will be infinite, because cloneBefore moves the current node</span>
  <span class="code_comment">// to the next index</span>
}

rule.each(<span class="code_function"><span class="code_params">decl</span> =></span> {
  decl.cloneBefore({ <span class="code_attr">prop</span>: <span class="code_string">'-webkit-'</span> + decl.prop })
  <span class="code_comment">// Will be executed only for color and z-index</span>
})</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>callback</code></td><td>(node: <a href="#childnode">ChildNode</a>, index: number) => false | void</td><td>Iterator receives each node and index.
</td></tr></table><p>Returns <code>void | false</code>. Returns <code>false</code> if iteration was broke.
</p><h2 id="default-error" class="doc_subtitle"><span class="doc_prefix">default#</span>error()</h2><p>Returns a <code><a href="#csssyntaxerror">CssSyntaxError</a></code> instance containing the original position
of the node in the source, showing line and column numbers and also
a small excerpt to facilitate debugging.</p>
<p>If present, an input source map will be used to get the original position
of the source, even from a previous compilation step
(e.g., from Sass compilation).</p>
<p>This method produces very useful error messages.</p>
<pre><code class="code"><span class="code_keyword">if</span> (!variables[name]) {
  <span class="code_keyword">throw</span> decl.error(<span class="code_string">`Unknown variable <span class="code_subst">${name}</span>`</span>, { <span class="code_attr">word</span>: name })
  <span class="code_comment">// CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black</span>
  <span class="code_comment">//   color: $black</span>
  <span class="code_comment">// a</span>
  <span class="code_comment">//          ^</span>
  <span class="code_comment">//   background: white</span>
}</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>message</code></td><td>string</td><td>Error description.
</td></tr><tr><td><code>options</code></td><td><a href="#nodeerroroptions">NodeErrorOptions</a></td><td></td></tr></table><p>Returns <code>default</code>. Error object to throw it.
</p><h2 id="default-every" class="doc_subtitle"><span class="doc_prefix">default#</span>every()</h2><p>Returns <code>true</code> if callback returns <code>true</code>
for all of the container’s children.</p>
<pre><code class="code"><span class="code_keyword">const</span> noPrefixes = rule.every(<span class="code_function"><span class="code_params">i</span> =></span> i.prop[<span class="code_number">0</span>] !== <span class="code_string">'-'</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>condition</code></td><td>(node: <a href="#childnode">ChildNode</a>, index: number, nodes: <a href="#childnode">ChildNode</a>[]) => boolean</td><td>Iterator returns true or false.
</td></tr></table><p>Returns <code>boolean</code>. Is every child pass condition.
</p><h2 id="default-index" class="doc_subtitle"><span class="doc_prefix">default#</span>index()</h2><p>Returns a <code>child</code>’s index within the <code><a href="#container-nodes">Container#nodes</a></code> array.</p>
<pre><code class="code">rule.index( rule.nodes[<span class="code_number">2</span>] ) <span class="code_comment">//=> 2</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td>number | default | default | default | default</td><td>Child of the current container.
</td></tr></table><p>Returns <code>number</code>. Child index.
</p><h2 id="default-insertafter" class="doc_subtitle"><span class="doc_prefix">default#</span>insertAfter()</h2><p>Insert new node after old node within the container.</p>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>oldNode</code></td><td>number | default | default | default | default</td><td>Child or child’s index.
</td></tr><tr><td><code>newNode</code></td><td>string | <a href="#atruleprops">AtRuleProps</a> | default | default | default | default | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | <a href="#childnode">ChildNode</a>[] | <a href="#childprops">ChildProps</a>[] | string[]</td><td>New node.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-insertbefore" class="doc_subtitle"><span class="doc_prefix">default#</span>insertBefore()</h2><p>Insert new node before old node within the container.</p>
<pre><code class="code">rule.insertBefore(decl, decl.clone({ <span class="code_attr">prop</span>: <span class="code_string">'-webkit-'</span> + decl.prop }))</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>oldNode</code></td><td>number | default | default | default | default</td><td>Child or child’s index.
</td></tr><tr><td><code>newNode</code></td><td>string | <a href="#atruleprops">AtRuleProps</a> | default | default | default | default | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | <a href="#childnode">ChildNode</a>[] | <a href="#childprops">ChildProps</a>[] | string[]</td><td>New node.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-next" class="doc_subtitle"><span class="doc_prefix">default#</span>next()</h2><p>Returns the next child of the node’s parent.
Returns <code>undefined</code> if the current node is the last child.</p>
<pre><code class="code"><span class="code_keyword">if</span> (comment.text === <span class="code_string">'delete next'</span>) {
  <span class="code_keyword">const</span> next = comment.next()
  <span class="code_keyword">if</span> (next) {
    next.remove()
  }
}</code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code><a href="#childnode">ChildNode</a></code>. Next node.
</p><h2 id="default-positioninside" class="doc_subtitle"><span class="doc_prefix">default#</span>positionInside()</h2><p>Convert string index to line/column.</p>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>number</td><td>The symbol number in the node’s string.
</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. Symbol position in file.
</p><h2 id="default-prepend" class="doc_subtitle"><span class="doc_prefix">default#</span>prepend()</h2><p>Inserts new nodes to the start of the container.</p>
<pre><code class="code"><span class="code_keyword">const</span> decl1 = <span class="code_keyword">new</span> Declaration({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> })
<span class="code_keyword">const</span> decl2 = <span class="code_keyword">new</span> Declaration({ <span class="code_attr">prop</span>: <span class="code_string">'background-color'</span>, <span class="code_attr">value</span>: <span class="code_string">'white'</span> })
rule.prepend(decl1, decl2)

root.append({ <span class="code_attr">name</span>: <span class="code_string">'charset'</span>, <span class="code_attr">params</span>: <span class="code_string">'"UTF-8"'</span> })  <span class="code_comment">// at-rule</span>
root.append({ <span class="code_attr">selector</span>: <span class="code_string">'a'</span> })                       <span class="code_comment">// rule</span>
rule.append({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> })       <span class="code_comment">// declaration</span>
rule.append({ <span class="code_attr">text</span>: <span class="code_string">'Comment'</span> })                     <span class="code_comment">// comment</span>

root.append(<span class="code_string">'a {}'</span>)
root.first.append(<span class="code_string">'color: black; z-index: 1'</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td>(string | <a href="#atruleprops">AtRuleProps</a> | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | default | default[] | <a href="#childprops">ChildProps</a>[] | string[])[]</td><td>New nodes.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-prev" class="doc_subtitle"><span class="doc_prefix">default#</span>prev()</h2><p>Returns the previous child of the node’s parent.
Returns <code>undefined</code> if the current node is the first child.</p>
<pre><code class="code"><span class="code_keyword">const</span> annotation = decl.prev()
<span class="code_keyword">if</span> (annotation.type === <span class="code_string">'comment'</span>) {
  readAnnotation(annotation.text)
}</code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code><a href="#childnode">ChildNode</a></code>. Previous node.
</p><h2 id="default-push" class="doc_subtitle"><span class="doc_prefix">default#</span>push()</h2><p>Add child to the end of the node.</p>
<pre><code class="code">rule.push(<span class="code_keyword">new</span> Declaration({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> }))</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td><a href="#childnode">ChildNode</a></td><td>New node.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-raw" class="doc_subtitle"><span class="doc_prefix">default#</span>raw()</h2><p>Returns a <code><a href="#node-raws">Node#raws</a></code> value. If the node is missing
the code style property (because the node was manually built or cloned),
PostCSS will try to autodetect the code style property by looking
at other nodes in the tree.</p>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(<span class="code_string">'a { background: white }'</span>)
root.nodes[<span class="code_number">0</span>].append({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> })
root.nodes[<span class="code_number">0</span>].nodes[<span class="code_number">1</span>].raws.before   <span class="code_comment">//=> undefined</span>
root.nodes[<span class="code_number">0</span>].nodes[<span class="code_number">1</span>].raw(<span class="code_string">'before'</span>) <span class="code_comment">//=> ' '</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>prop</code></td><td>string</td><td>Name of code style property.
</td></tr><tr><td><code>defaultType</code></td><td>string</td><td>Name of default value, it can be missed
if the value is the same as prop.
</td></tr></table><p>Returns <code>string</code>. Code style value.
</p><h2 id="default-remove" class="doc_subtitle"><span class="doc_prefix">default#</span>remove()</h2><p>Removes the node from its parent and cleans the parent properties
from the node and its children.</p>
<pre><code class="code"><span class="code_keyword">if</span> (decl.prop.match(<span class="code_regexp">/^-webkit-/</span>)) {
  decl.remove()
}</code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>default</code>. Node to make calls chain.
</p><h2 id="default-removeall" class="doc_subtitle"><span class="doc_prefix">default#</span>removeAll()</h2><p>Removes all children from the container
and cleans their parent properties.</p>
<pre><code class="code">rule.removeAll()
rule.nodes.length <span class="code_comment">//=> 0</span></code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-removechild" class="doc_subtitle"><span class="doc_prefix">default#</span>removeChild()</h2><p>Removes node from the container and cleans the parent properties
from the node and its children.</p>
<pre><code class="code">rule.nodes.length  <span class="code_comment">//=> 5</span>
rule.removeChild(decl)
rule.nodes.length  <span class="code_comment">//=> 4</span>
decl.parent        <span class="code_comment">//=> undefined</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td>number | default | default | default | default</td><td>Child or child’s index.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-replacevalues" class="doc_subtitle"><span class="doc_prefix">default#</span>replaceValues()</h2><p>Passes all declaration values within the container that match pattern
through callback, replacing those values with the returned result
of callback.</p>
<p>This method is useful if you are using a custom unit or function
and need to iterate through all values.</p>
<pre><code class="code">root.replaceValues(<span class="code_regexp">/\d+rem/</span>, { <span class="code_attr">fast</span>: <span class="code_string">'rem'</span> }, <span class="code_function"><span class="code_params">string</span> =></span> {
  <span class="code_keyword">return</span> <span class="code_number">15</span> * <span class="code_built_in">parseInt</span>(string) + <span class="code_string">'px'</span>
})</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>pattern</code></td><td>string | RegExp</td><td>Replace pattern.
</td></tr><tr><td><code>options</code></td><td><a href="#valueoptions">ValueOptions</a></td><td></td></tr><tr><td><code>replaced</code></td><td>string | (substring: string, args: any[]) => string</td><td></td></tr></table><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>pattern</code></td><td>string | RegExp</td><td>Replace pattern.
</td></tr><tr><td><code>replaced</code></td><td>string | (substring: string, args: any[]) => string</td><td></td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-replacewith" class="doc_subtitle"><span class="doc_prefix">default#</span>replaceWith()</h2><p>Inserts node(s) before the current node and removes the current node.</p>
<pre><code class="code">AtRule: {
  <span class="code_attr">mixin</span>: <span class="code_function"><span class="code_params">atrule</span> =></span> {
    atrule.replaceWith(mixinRules[atrule.params])
  }
}</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td>(<a href="#atruleprops">AtRuleProps</a> | default | default | default | default | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | <a href="#childnode">ChildNode</a>[] | <a href="#childprops">ChildProps</a>[])[]</td><td>Mode(s) to replace current one.
</td></tr></table><p>Returns <code>default</code>. Current node to methods chain.
</p><h2 id="default-root" class="doc_subtitle"><span class="doc_prefix">default#</span>root()</h2><p>Finds the Root instance of the node’s tree.</p>
<pre><code class="code">root.nodes[<span class="code_number">0</span>].nodes[<span class="code_number">0</span>].root() === root</code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>default</code>. Root parent.
</p><h2 id="default-some" class="doc_subtitle"><span class="doc_prefix">default#</span>some()</h2><p>Returns <code>true</code> if callback returns <code>true</code> for (at least) one
of the container’s children.</p>
<pre><code class="code"><span class="code_keyword">const</span> hasPrefix = rule.some(<span class="code_function"><span class="code_params">i</span> =></span> i.prop[<span class="code_number">0</span>] === <span class="code_string">'-'</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>condition</code></td><td>(node: <a href="#childnode">ChildNode</a>, index: number, nodes: <a href="#childnode">ChildNode</a>[]) => boolean</td><td>Iterator returns true or false.
</td></tr></table><p>Returns <code>boolean</code>. Is some child pass condition.
</p><h2 id="default-tojson" class="doc_subtitle"><span class="doc_prefix">default#</span>toJSON()</h2><p>Fix circular links on <code>JSON.stringify()</code>.</p>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>object</code>. Cleaned object.
</p><h2 id="default-toresult" class="doc_subtitle"><span class="doc_prefix">default#</span>toResult()</h2><p>Returns a <code><a href="#result">Result</a></code> instance representing the root’s CSS.</p>
<pre><code class="code"><span class="code_keyword">const</span> root1 = postcss.parse(css1, { <span class="code_attr">from</span>: <span class="code_string">'a.css'</span> })
<span class="code_keyword">const</span> root2 = postcss.parse(css2, { <span class="code_attr">from</span>: <span class="code_string">'b.css'</span> })
root1.append(root2)
<span class="code_keyword">const</span> result = root1.toResult({ <span class="code_attr">to</span>: <span class="code_string">'all.css'</span>, <span class="code_attr">map</span>: <span class="code_literal">true</span> })</code></pre>
<table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>options</code></td><td><a href="#processoptions">ProcessOptions</a></td></tr></table><p>Returns <code>default</code>. Result with current root’s CSS.
</p><h2 id="default-tostring" class="doc_subtitle"><span class="doc_prefix">default#</span>toString()</h2><p>Returns a CSS string representing the node.</p>
<pre><code class="code"><span class="code_keyword">new</span> Rule({ <span class="code_attr">selector</span>: <span class="code_string">'a'</span> }).toString() <span class="code_comment">//=> "a {}"</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>stringifier</code></td><td><a href="#stringifier">Stringifier</a> | <a href="#syntax">Syntax</a></td><td>A syntax to use in string generation.
</td></tr></table><p>Returns <code>string</code>. CSS string of this node.
</p><h2 id="default-walk" class="doc_subtitle"><span class="doc_prefix">default#</span>walk()</h2><p>Traverses the container’s descendant nodes, calling callback
for each node.</p>
<p>Like container.each(), this method is safe to use
if you are mutating arrays during iteration.</p>
<p>If you only need to iterate through the container’s immediate children,
use <code><a href="#container-each">Container#each</a></code>.</p>
<pre><code class="code">root.walk(<span class="code_function"><span class="code_params">node</span> =></span> {
  <span class="code_comment">// Traverses all descendant nodes.</span>
})</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>callback</code></td><td>(node: <a href="#childnode">ChildNode</a>, index: number) => false | void</td><td>Iterator receives each node and index.
</td></tr></table><p>Returns <code>void | false</code>. Returns <code>false</code> if iteration was broke.
</p><h2 id="default-walkatrules" class="doc_subtitle"><span class="doc_prefix">default#</span>walkAtRules()</h2><p>Traverses the container’s descendant nodes, calling callback
for each at-rule node.</p>
<p>If you pass a filter, iteration will only happen over at-rules
that have matching names.</p>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<pre><code class="code">root.walkAtRules(<span class="code_function"><span class="code_params">rule</span> =></span> {
  <span class="code_keyword">if</span> (isOld(rule.name)) rule.remove()
})

<span class="code_keyword">let</span> first = <span class="code_literal">false</span>
root.walkAtRules(<span class="code_string">'charset'</span>, <span class="code_function"><span class="code_params">rule</span> =></span> {
  <span class="code_keyword">if</span> (!first) {
    first = <span class="code_literal">true</span>
  } <span class="code_keyword">else</span> {
    rule.remove()
  }
})</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nameFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>(atRule: default, index: number) => false | void</td><td>Iterator receives each node and index.
</td></tr></table><p>Returns <code>void | false</code>. Returns <code>false</code> if iteration was broke.
</p><h2 id="default-walkcomments" class="doc_subtitle"><span class="doc_prefix">default#</span>walkComments()</h2><p>Traverses the container’s descendant nodes, calling callback
for each comment node.</p>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<pre><code class="code">root.walkComments(<span class="code_function"><span class="code_params">comment</span> =></span> {
  comment.remove()
})</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>callback</code></td><td>(comment: default, indexed: number) => false | void</td><td>Iterator receives each node and index.
</td></tr></table><p>Returns <code>void | false</code>. Returns <code>false</code> if iteration was broke.
</p><h2 id="default-walkdecls" class="doc_subtitle"><span class="doc_prefix">default#</span>walkDecls()</h2><p>Traverses the container’s descendant nodes, calling callback
for each declaration node.</p>
<p>If you pass a filter, iteration will only happen over declarations
with matching properties.</p>
<pre><code class="code">root.walkDecls(<span class="code_function"><span class="code_params">decl</span> =></span> {
  checkPropertySupport(decl.prop)
})

root.walkDecls(<span class="code_string">'border-radius'</span>, <span class="code_function"><span class="code_params">decl</span> =></span> {
  decl.remove()
})

root.walkDecls(<span class="code_regexp">/^background/</span>, <span class="code_function"><span class="code_params">decl</span> =></span> {
  decl.value = takeFirstColorFromGradient(decl.value)
})</code></pre>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>propFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>(decl: default, index: number) => false | void</td><td>Iterator receives each node and index.
</td></tr></table><p>Returns <code>void | false</code>. Returns <code>false</code> if iteration was broke.
</p><h2 id="default-walkrules" class="doc_subtitle"><span class="doc_prefix">default#</span>walkRules()</h2><p>Traverses the container’s descendant nodes, calling callback
for each rule node.</p>
<p>If you pass a filter, iteration will only happen over rules
with matching selectors.</p>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<pre><code class="code"><span class="code_keyword">const</span> selectors = []
root.walkRules(<span class="code_function"><span class="code_params">rule</span> =></span> {
  selectors.push(rule.selector)
})
<span class="code_built_in">console</span>.log(<span class="code_string">`Your CSS uses <span class="code_subst">${ selectors.length }</span> selectors`</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>selectorFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>(atRule: default, index: number) => false | void</td><td>Iterator receives each node and index.
</td></tr></table><p>Returns <code>void | false</code>. Returns <code>false</code> if iteration was broke.
</p><h2 id="default-warn" class="doc_subtitle"><span class="doc_prefix">default#</span>warn()</h2><p>This method is provided as a convenience wrapper for <code><a href="#result-warn">Result#warn</a></code>.</p>
<pre><code class="code">  Declaration: {
    <span class="code_attr">bad</span>: <span class="code_function">(<span class="code_params">decl, { result }</span>) =></span> {
      decl.warn(result, <span class="code_string">'Deprecated property bad'</span>)
    }
  }</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>result</code></td><td>default</td><td>The <code><a href="#result">Result</a></code> instance that will receive the warning.
</td></tr><tr><td><code>text</code></td><td>string</td><td>Warning message.
</td></tr><tr><td><code>opts</code></td><td><a href="#warningoptions">WarningOptions</a></td><td>Warning Options.
</td></tr></table></section><section class="doc"><h1 id="default" class="doc_title">default</h1><p>Represents a CSS rule: a selector followed by a declaration block.</p>
<pre><code class="code">Once (root, { Rule }) {
  <span class="code_keyword">let</span> a = <span class="code_keyword">new</span> Rule({ <span class="code_attr">selector</span>: <span class="code_string">'a'</span> })
  a.append(…)
  root.append(a)
}</code></pre>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(<span class="code_string">'a{}'</span>)
<span class="code_keyword">const</span> rule = root.first
rule.type       <span class="code_comment">//=> 'rule'</span>
rule.toString() <span class="code_comment">//=> 'a{}'</span></code></pre>
<h2 id="default-nodes" class="doc_subtitle"><span class="doc_prefix">default#</span>nodes</h2><p>An array containing the container’s children.</p>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(<span class="code_string">'a { color: black }'</span>)
root.nodes.length           <span class="code_comment">//=> 1</span>
root.nodes[<span class="code_number">0</span>].selector      <span class="code_comment">//=> 'a'</span>
root.nodes[<span class="code_number">0</span>].nodes[<span class="code_number">0</span>].prop <span class="code_comment">//=> 'color'</span></code></pre>
<p>Type: <a href="#childnode">ChildNode</a>[].</p><h2 id="default-parent" class="doc_subtitle"><span class="doc_prefix">default#</span>parent</h2><p>The node’s parent node.</p>
<pre><code class="code">root.nodes[<span class="code_number">0</span>].parent === root</code></pre>
<p>Type: default.</p><h2 id="default-raws" class="doc_subtitle"><span class="doc_prefix">default#</span>raws</h2><p>Information to generate byte-to-byte equal node string as it was
in the origin input.</p>
<p>Every parser saves its own properties,
but the default CSS parser uses:</p>
<ul>
<li><code>before</code>: the space symbols before the node. It also stores <code>*</code>
and <code>_</code> symbols before the declaration (IE hack).</li>
<li><code>after</code>: the space symbols after the last child of the node
to the end of the node.</li>
<li><code>between</code>: the symbols between the property and value
for declarations, selector and <code>{</code> for rules, or last parameter
and <code>{</code> for at-rules.</li>
<li><code>semicolon</code>: contains true if the last child has
an (optional) semicolon.</li>
<li><code>afterName</code>: the space between the at-rule name and its parameters.</li>
<li><code>left</code>: the space symbols between <code>/*</code> and the comment’s text.</li>
<li><code>right</code>: the space symbols between the comment’s text
and <code>*/</code>.</li>
<li><code>important</code>: the content of the important statement,
if it is not just <code>!important</code>.</li>
</ul>
<p>PostCSS cleans selectors, declaration values and at-rule parameters
from comments and extra spaces, but it stores origin content in raws
properties. As such, if you don’t change a declaration’s value,
PostCSS will use the raw value with comments.</p>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(<span class="code_string">'a {\n  color:black\n}'</span>)
root.first.first.raws <span class="code_comment">//=> { before: '\n  ', between: ':' }</span></code></pre>
<p>Type: <a href="#ruleraws">RuleRaws</a>.</p><h2 id="default-selector" class="doc_subtitle"><span class="doc_prefix">default#</span>selector</h2><p>The rule’s full selector represented as a string.</p>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(<span class="code_string">'a, b { }'</span>)
<span class="code_keyword">const</span> rule = root.first
rule.selector <span class="code_comment">//=> 'a, b'</span></code></pre>
<p>Type: string.</p><h2 id="default-selectors" class="doc_subtitle"><span class="doc_prefix">default#</span>selectors</h2><p>An array containing the rule’s individual selectors.
Groups of selectors are split at commas.</p>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(<span class="code_string">'a, b { }'</span>)
<span class="code_keyword">const</span> rule = root.first

rule.selector  <span class="code_comment">//=> 'a, b'</span>
rule.selectors <span class="code_comment">//=> ['a', 'b']</span>

rule.selectors = [<span class="code_string">'a'</span>, <span class="code_string">'strong'</span>]
rule.selector <span class="code_comment">//=> 'a, strong'</span></code></pre>
<p>Type: string[].</p><h2 id="default-source" class="doc_subtitle"><span class="doc_prefix">default#</span>source</h2><p>The input source of the node.</p>
<p>The property is used in source map generation.</p>
<p>If you create a node manually (e.g., with <code>postcss.decl()</code>),
that node will not have a <code>source</code> property and will be absent
from the source map. For this reason, the plugin developer should
consider cloning nodes to create new ones (in which case the new node’s
source will reference the original, cloned node) or setting
the <code>source</code> property manually.</p>
<pre><code class="code">decl.source.input.from <span class="code_comment">//=> '/home/ai/a.sass'</span>
decl.source.start      <span class="code_comment">//=> { line: 10, column: 2 }</span>
decl.source.end        <span class="code_comment">//=> { line: 10, column: 12 }</span></code></pre>
<pre><code class="code"><span class="code_comment">// Bad</span>
<span class="code_keyword">const</span> prefixed = postcss.decl({
  <span class="code_attr">prop</span>: <span class="code_string">'-moz-'</span> + decl.prop,
  <span class="code_attr">value</span>: decl.value
})

<span class="code_comment">// Good</span>
<span class="code_keyword">const</span> prefixed = decl.clone({ <span class="code_attr">prop</span>: <span class="code_string">'-moz-'</span> + decl.prop })</code></pre>
<pre><code class="code"><span class="code_keyword">if</span> (atrule.name === <span class="code_string">'add-link'</span>) {
  <span class="code_keyword">const</span> rule = postcss.rule({ <span class="code_attr">selector</span>: <span class="code_string">'a'</span>, <span class="code_attr">source</span>: atrule.source })
  atrule.parent.insertBefore(atrule, rule)
}</code></pre>
<p>Type: <a href="#source">Source</a>.</p><h2 id="default-type" class="doc_subtitle"><span class="doc_prefix">default#</span>type</h2><p>tring representing the node’s type. Possible values are <code>root</code>, <code>atrule</code>,
<code>rule</code>, <code>decl</code>, or <code>comment</code>.</p>
<pre><code class="code"><span class="code_keyword">new</span> Declaration({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> }).type <span class="code_comment">//=> 'decl'</span></code></pre>
<p>Type: "rule".</p><h2 id="default-first" class="doc_subtitle"><span class="doc_prefix">default#</span>first</h2><p>The container’s first child.</p>
<pre><code class="code">rule.first === rules.nodes[<span class="code_number">0</span>]</code></pre>
<h2 id="default-last" class="doc_subtitle"><span class="doc_prefix">default#</span>last</h2><p>The container’s last child.</p>
<pre><code class="code">rule.last === rule.nodes[rule.nodes.length - <span class="code_number">1</span>]</code></pre>
<h2 id="default-after" class="doc_subtitle"><span class="doc_prefix">default#</span>after()</h2><p>Insert new node after current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertAfter(node, add)</code>.</p>
<pre><code class="code">decl.after(<span class="code_string">'color: black'</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#atruleprops">AtRuleProps</a> | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | default | default[]</td><td>New node.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-append" class="doc_subtitle"><span class="doc_prefix">default#</span>append()</h2><p>Inserts new nodes to the end of the container.</p>
<pre><code class="code"><span class="code_keyword">const</span> decl1 = <span class="code_keyword">new</span> Declaration({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> })
<span class="code_keyword">const</span> decl2 = <span class="code_keyword">new</span> Declaration({ <span class="code_attr">prop</span>: <span class="code_string">'background-color'</span>, <span class="code_attr">value</span>: <span class="code_string">'white'</span> })
rule.append(decl1, decl2)

root.append({ <span class="code_attr">name</span>: <span class="code_string">'charset'</span>, <span class="code_attr">params</span>: <span class="code_string">'"UTF-8"'</span> })  <span class="code_comment">// at-rule</span>
root.append({ <span class="code_attr">selector</span>: <span class="code_string">'a'</span> })                       <span class="code_comment">// rule</span>
rule.append({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> })       <span class="code_comment">// declaration</span>
rule.append({ <span class="code_attr">text</span>: <span class="code_string">'Comment'</span> })                     <span class="code_comment">// comment</span>

root.append(<span class="code_string">'a {}'</span>)
root.first.append(<span class="code_string">'color: black; z-index: 1'</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td>(string | <a href="#atruleprops">AtRuleProps</a> | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | default | default[] | <a href="#childprops">ChildProps</a>[] | string[])[]</td><td>New nodes.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-before" class="doc_subtitle"><span class="doc_prefix">default#</span>before()</h2><p>Insert new node before current node to current node’s parent.</p>
<p>Just alias for <code>node.parent.insertBefore(node, add)</code>.</p>
<pre><code class="code">decl.before(<span class="code_string">'content: ""'</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>newNode</code></td><td>string | <a href="#atruleprops">AtRuleProps</a> | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | default | default[]</td><td>New node.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-cleanraws" class="doc_subtitle"><span class="doc_prefix">default#</span>cleanRaws()</h2><p>Clear the code style properties for the node and its children.</p>
<pre><code class="code">node.raws.before  <span class="code_comment">//=> ' '</span>
node.cleanRaws()
node.raws.before  <span class="code_comment">//=> undefined</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>keepBetween</code></td><td>boolean</td><td>Keep the <code>raws.between</code> symbols.
</td></tr></table><h2 id="default-clone" class="doc_subtitle"><span class="doc_prefix">default#</span>clone()</h2><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#ruleprops">RuleProps</a>></td><td>New properties to override in the clone.
</td></tr></table><p>Returns <code>default</code>. </p><h2 id="default-cloneafter" class="doc_subtitle"><span class="doc_prefix">default#</span>cloneAfter()</h2><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#ruleprops">RuleProps</a>></td><td>New properties to override in the clone.
</td></tr></table><p>Returns <code>default</code>. </p><h2 id="default-clonebefore" class="doc_subtitle"><span class="doc_prefix">default#</span>cloneBefore()</h2><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>overrides</code></td><td>Partial&lt;<a href="#ruleprops">RuleProps</a>></td><td>Mew properties to override in the clone.
</td></tr></table><p>Returns <code>default</code>. </p><h2 id="default-each" class="doc_subtitle"><span class="doc_prefix">default#</span>each()</h2><p>Iterates through the container’s immediate children,
calling <code>callback</code> for each child.</p>
<p>Returning <code>false</code> in the callback will break iteration.</p>
<p>This method only iterates through the container’s immediate children.
If you need to recursively iterate through all the container’s descendant
nodes, use <code><a href="#container-walk">Container#walk</a></code>.</p>
<p>Unlike the for <code>{}</code>-cycle or <code>Array#forEach</code> this iterator is safe
if you are mutating the array of child nodes during iteration.
PostCSS will adjust the current index to match the mutations.</p>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(<span class="code_string">'a { color: black; z-index: 1 }'</span>)
<span class="code_keyword">const</span> rule = root.first

<span class="code_keyword">for</span> (<span class="code_keyword">const</span> decl <span class="code_keyword">of</span> rule.nodes) {
  decl.cloneBefore({ <span class="code_attr">prop</span>: <span class="code_string">'-webkit-'</span> + decl.prop })
  <span class="code_comment">// Cycle will be infinite, because cloneBefore moves the current node</span>
  <span class="code_comment">// to the next index</span>
}

rule.each(<span class="code_function"><span class="code_params">decl</span> =></span> {
  decl.cloneBefore({ <span class="code_attr">prop</span>: <span class="code_string">'-webkit-'</span> + decl.prop })
  <span class="code_comment">// Will be executed only for color and z-index</span>
})</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>callback</code></td><td>(node: <a href="#childnode">ChildNode</a>, index: number) => false | void</td><td>Iterator receives each node and index.
</td></tr></table><p>Returns <code>void | false</code>. Returns <code>false</code> if iteration was broke.
</p><h2 id="default-error" class="doc_subtitle"><span class="doc_prefix">default#</span>error()</h2><p>Returns a <code><a href="#csssyntaxerror">CssSyntaxError</a></code> instance containing the original position
of the node in the source, showing line and column numbers and also
a small excerpt to facilitate debugging.</p>
<p>If present, an input source map will be used to get the original position
of the source, even from a previous compilation step
(e.g., from Sass compilation).</p>
<p>This method produces very useful error messages.</p>
<pre><code class="code"><span class="code_keyword">if</span> (!variables[name]) {
  <span class="code_keyword">throw</span> decl.error(<span class="code_string">`Unknown variable <span class="code_subst">${name}</span>`</span>, { <span class="code_attr">word</span>: name })
  <span class="code_comment">// CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black</span>
  <span class="code_comment">//   color: $black</span>
  <span class="code_comment">// a</span>
  <span class="code_comment">//          ^</span>
  <span class="code_comment">//   background: white</span>
}</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>message</code></td><td>string</td><td>Error description.
</td></tr><tr><td><code>options</code></td><td><a href="#nodeerroroptions">NodeErrorOptions</a></td><td></td></tr></table><p>Returns <code>default</code>. Error object to throw it.
</p><h2 id="default-every" class="doc_subtitle"><span class="doc_prefix">default#</span>every()</h2><p>Returns <code>true</code> if callback returns <code>true</code>
for all of the container’s children.</p>
<pre><code class="code"><span class="code_keyword">const</span> noPrefixes = rule.every(<span class="code_function"><span class="code_params">i</span> =></span> i.prop[<span class="code_number">0</span>] !== <span class="code_string">'-'</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>condition</code></td><td>(node: <a href="#childnode">ChildNode</a>, index: number, nodes: <a href="#childnode">ChildNode</a>[]) => boolean</td><td>Iterator returns true or false.
</td></tr></table><p>Returns <code>boolean</code>. Is every child pass condition.
</p><h2 id="default-index" class="doc_subtitle"><span class="doc_prefix">default#</span>index()</h2><p>Returns a <code>child</code>’s index within the <code><a href="#container-nodes">Container#nodes</a></code> array.</p>
<pre><code class="code">rule.index( rule.nodes[<span class="code_number">2</span>] ) <span class="code_comment">//=> 2</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td>number | default | default | default | default</td><td>Child of the current container.
</td></tr></table><p>Returns <code>number</code>. Child index.
</p><h2 id="default-insertafter" class="doc_subtitle"><span class="doc_prefix">default#</span>insertAfter()</h2><p>Insert new node after old node within the container.</p>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>oldNode</code></td><td>number | default | default | default | default</td><td>Child or child’s index.
</td></tr><tr><td><code>newNode</code></td><td>string | <a href="#atruleprops">AtRuleProps</a> | default | default | default | default | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | <a href="#childnode">ChildNode</a>[] | <a href="#childprops">ChildProps</a>[] | string[]</td><td>New node.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-insertbefore" class="doc_subtitle"><span class="doc_prefix">default#</span>insertBefore()</h2><p>Insert new node before old node within the container.</p>
<pre><code class="code">rule.insertBefore(decl, decl.clone({ <span class="code_attr">prop</span>: <span class="code_string">'-webkit-'</span> + decl.prop }))</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>oldNode</code></td><td>number | default | default | default | default</td><td>Child or child’s index.
</td></tr><tr><td><code>newNode</code></td><td>string | <a href="#atruleprops">AtRuleProps</a> | default | default | default | default | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | <a href="#childnode">ChildNode</a>[] | <a href="#childprops">ChildProps</a>[] | string[]</td><td>New node.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-next" class="doc_subtitle"><span class="doc_prefix">default#</span>next()</h2><p>Returns the next child of the node’s parent.
Returns <code>undefined</code> if the current node is the last child.</p>
<pre><code class="code"><span class="code_keyword">if</span> (comment.text === <span class="code_string">'delete next'</span>) {
  <span class="code_keyword">const</span> next = comment.next()
  <span class="code_keyword">if</span> (next) {
    next.remove()
  }
}</code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code><a href="#childnode">ChildNode</a></code>. Next node.
</p><h2 id="default-positioninside" class="doc_subtitle"><span class="doc_prefix">default#</span>positionInside()</h2><p>Convert string index to line/column.</p>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>number</td><td>The symbol number in the node’s string.
</td></tr></table><p>Returns <code><a href="#position">Position</a></code>. Symbol position in file.
</p><h2 id="default-prepend" class="doc_subtitle"><span class="doc_prefix">default#</span>prepend()</h2><p>Inserts new nodes to the start of the container.</p>
<pre><code class="code"><span class="code_keyword">const</span> decl1 = <span class="code_keyword">new</span> Declaration({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> })
<span class="code_keyword">const</span> decl2 = <span class="code_keyword">new</span> Declaration({ <span class="code_attr">prop</span>: <span class="code_string">'background-color'</span>, <span class="code_attr">value</span>: <span class="code_string">'white'</span> })
rule.prepend(decl1, decl2)

root.append({ <span class="code_attr">name</span>: <span class="code_string">'charset'</span>, <span class="code_attr">params</span>: <span class="code_string">'"UTF-8"'</span> })  <span class="code_comment">// at-rule</span>
root.append({ <span class="code_attr">selector</span>: <span class="code_string">'a'</span> })                       <span class="code_comment">// rule</span>
rule.append({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> })       <span class="code_comment">// declaration</span>
rule.append({ <span class="code_attr">text</span>: <span class="code_string">'Comment'</span> })                     <span class="code_comment">// comment</span>

root.append(<span class="code_string">'a {}'</span>)
root.first.append(<span class="code_string">'color: black; z-index: 1'</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td>(string | <a href="#atruleprops">AtRuleProps</a> | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | default | default[] | <a href="#childprops">ChildProps</a>[] | string[])[]</td><td>New nodes.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-prev" class="doc_subtitle"><span class="doc_prefix">default#</span>prev()</h2><p>Returns the previous child of the node’s parent.
Returns <code>undefined</code> if the current node is the first child.</p>
<pre><code class="code"><span class="code_keyword">const</span> annotation = decl.prev()
<span class="code_keyword">if</span> (annotation.type === <span class="code_string">'comment'</span>) {
  readAnnotation(annotation.text)
}</code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code><a href="#childnode">ChildNode</a></code>. Previous node.
</p><h2 id="default-push" class="doc_subtitle"><span class="doc_prefix">default#</span>push()</h2><p>Add child to the end of the node.</p>
<pre><code class="code">rule.push(<span class="code_keyword">new</span> Declaration({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> }))</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td><a href="#childnode">ChildNode</a></td><td>New node.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-raw" class="doc_subtitle"><span class="doc_prefix">default#</span>raw()</h2><p>Returns a <code><a href="#node-raws">Node#raws</a></code> value. If the node is missing
the code style property (because the node was manually built or cloned),
PostCSS will try to autodetect the code style property by looking
at other nodes in the tree.</p>
<pre><code class="code"><span class="code_keyword">const</span> root = postcss.parse(<span class="code_string">'a { background: white }'</span>)
root.nodes[<span class="code_number">0</span>].append({ <span class="code_attr">prop</span>: <span class="code_string">'color'</span>, <span class="code_attr">value</span>: <span class="code_string">'black'</span> })
root.nodes[<span class="code_number">0</span>].nodes[<span class="code_number">1</span>].raws.before   <span class="code_comment">//=> undefined</span>
root.nodes[<span class="code_number">0</span>].nodes[<span class="code_number">1</span>].raw(<span class="code_string">'before'</span>) <span class="code_comment">//=> ' '</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>prop</code></td><td>string</td><td>Name of code style property.
</td></tr><tr><td><code>defaultType</code></td><td>string</td><td>Name of default value, it can be missed
if the value is the same as prop.
</td></tr></table><p>Returns <code>string</code>. Code style value.
</p><h2 id="default-remove" class="doc_subtitle"><span class="doc_prefix">default#</span>remove()</h2><p>Removes the node from its parent and cleans the parent properties
from the node and its children.</p>
<pre><code class="code"><span class="code_keyword">if</span> (decl.prop.match(<span class="code_regexp">/^-webkit-/</span>)) {
  decl.remove()
}</code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>default</code>. Node to make calls chain.
</p><h2 id="default-removeall" class="doc_subtitle"><span class="doc_prefix">default#</span>removeAll()</h2><p>Removes all children from the container
and cleans their parent properties.</p>
<pre><code class="code">rule.removeAll()
rule.nodes.length <span class="code_comment">//=> 0</span></code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-removechild" class="doc_subtitle"><span class="doc_prefix">default#</span>removeChild()</h2><p>Removes node from the container and cleans the parent properties
from the node and its children.</p>
<pre><code class="code">rule.nodes.length  <span class="code_comment">//=> 5</span>
rule.removeChild(decl)
rule.nodes.length  <span class="code_comment">//=> 4</span>
decl.parent        <span class="code_comment">//=> undefined</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>child</code></td><td>number | default | default | default | default</td><td>Child or child’s index.
</td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-replacevalues" class="doc_subtitle"><span class="doc_prefix">default#</span>replaceValues()</h2><p>Passes all declaration values within the container that match pattern
through callback, replacing those values with the returned result
of callback.</p>
<p>This method is useful if you are using a custom unit or function
and need to iterate through all values.</p>
<pre><code class="code">root.replaceValues(<span class="code_regexp">/\d+rem/</span>, { <span class="code_attr">fast</span>: <span class="code_string">'rem'</span> }, <span class="code_function"><span class="code_params">string</span> =></span> {
  <span class="code_keyword">return</span> <span class="code_number">15</span> * <span class="code_built_in">parseInt</span>(string) + <span class="code_string">'px'</span>
})</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>pattern</code></td><td>string | RegExp</td><td>Replace pattern.
</td></tr><tr><td><code>options</code></td><td><a href="#valueoptions">ValueOptions</a></td><td></td></tr><tr><td><code>replaced</code></td><td>string | (substring: string, args: any[]) => string</td><td></td></tr></table><table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>pattern</code></td><td>string | RegExp</td><td>Replace pattern.
</td></tr><tr><td><code>replaced</code></td><td>string | (substring: string, args: any[]) => string</td><td></td></tr></table><p>Returns <code>default</code>. This node for methods chain.
</p><h2 id="default-replacewith" class="doc_subtitle"><span class="doc_prefix">default#</span>replaceWith()</h2><p>Inserts node(s) before the current node and removes the current node.</p>
<pre><code class="code">AtRule: {
  <span class="code_attr">mixin</span>: <span class="code_function"><span class="code_params">atrule</span> =></span> {
    atrule.replaceWith(mixinRules[atrule.params])
  }
}</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nodes…</code></td><td>(<a href="#atruleprops">AtRuleProps</a> | default | default | default | default | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a> | <a href="#childnode">ChildNode</a>[] | <a href="#childprops">ChildProps</a>[])[]</td><td>Mode(s) to replace current one.
</td></tr></table><p>Returns <code>default</code>. Current node to methods chain.
</p><h2 id="default-root" class="doc_subtitle"><span class="doc_prefix">default#</span>root()</h2><p>Finds the Root instance of the node’s tree.</p>
<pre><code class="code">root.nodes[<span class="code_number">0</span>].nodes[<span class="code_number">0</span>].root() === root</code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>default</code>. Root parent.
</p><h2 id="default-some" class="doc_subtitle"><span class="doc_prefix">default#</span>some()</h2><p>Returns <code>true</code> if callback returns <code>true</code> for (at least) one
of the container’s children.</p>
<pre><code class="code"><span class="code_keyword">const</span> hasPrefix = rule.some(<span class="code_function"><span class="code_params">i</span> =></span> i.prop[<span class="code_number">0</span>] === <span class="code_string">'-'</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>condition</code></td><td>(node: <a href="#childnode">ChildNode</a>, index: number, nodes: <a href="#childnode">ChildNode</a>[]) => boolean</td><td>Iterator returns true or false.
</td></tr></table><p>Returns <code>boolean</code>. Is some child pass condition.
</p><h2 id="default-tojson" class="doc_subtitle"><span class="doc_prefix">default#</span>toJSON()</h2><p>Fix circular links on <code>JSON.stringify()</code>.</p>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>object</code>. Cleaned object.
</p><h2 id="default-tostring" class="doc_subtitle"><span class="doc_prefix">default#</span>toString()</h2><p>Returns a CSS string representing the node.</p>
<pre><code class="code"><span class="code_keyword">new</span> Rule({ <span class="code_attr">selector</span>: <span class="code_string">'a'</span> }).toString() <span class="code_comment">//=> "a {}"</span></code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>stringifier</code></td><td><a href="#stringifier">Stringifier</a> | <a href="#syntax">Syntax</a></td><td>A syntax to use in string generation.
</td></tr></table><p>Returns <code>string</code>. CSS string of this node.
</p><h2 id="default-walk" class="doc_subtitle"><span class="doc_prefix">default#</span>walk()</h2><p>Traverses the container’s descendant nodes, calling callback
for each node.</p>
<p>Like container.each(), this method is safe to use
if you are mutating arrays during iteration.</p>
<p>If you only need to iterate through the container’s immediate children,
use <code><a href="#container-each">Container#each</a></code>.</p>
<pre><code class="code">root.walk(<span class="code_function"><span class="code_params">node</span> =></span> {
  <span class="code_comment">// Traverses all descendant nodes.</span>
})</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>callback</code></td><td>(node: <a href="#childnode">ChildNode</a>, index: number) => false | void</td><td>Iterator receives each node and index.
</td></tr></table><p>Returns <code>void | false</code>. Returns <code>false</code> if iteration was broke.
</p><h2 id="default-walkatrules" class="doc_subtitle"><span class="doc_prefix">default#</span>walkAtRules()</h2><p>Traverses the container’s descendant nodes, calling callback
for each at-rule node.</p>
<p>If you pass a filter, iteration will only happen over at-rules
that have matching names.</p>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<pre><code class="code">root.walkAtRules(<span class="code_function"><span class="code_params">rule</span> =></span> {
  <span class="code_keyword">if</span> (isOld(rule.name)) rule.remove()
})

<span class="code_keyword">let</span> first = <span class="code_literal">false</span>
root.walkAtRules(<span class="code_string">'charset'</span>, <span class="code_function"><span class="code_params">rule</span> =></span> {
  <span class="code_keyword">if</span> (!first) {
    first = <span class="code_literal">true</span>
  } <span class="code_keyword">else</span> {
    rule.remove()
  }
})</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>nameFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>(atRule: default, index: number) => false | void</td><td>Iterator receives each node and index.
</td></tr></table><p>Returns <code>void | false</code>. Returns <code>false</code> if iteration was broke.
</p><h2 id="default-walkcomments" class="doc_subtitle"><span class="doc_prefix">default#</span>walkComments()</h2><p>Traverses the container’s descendant nodes, calling callback
for each comment node.</p>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<pre><code class="code">root.walkComments(<span class="code_function"><span class="code_params">comment</span> =></span> {
  comment.remove()
})</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>callback</code></td><td>(comment: default, indexed: number) => false | void</td><td>Iterator receives each node and index.
</td></tr></table><p>Returns <code>void | false</code>. Returns <code>false</code> if iteration was broke.
</p><h2 id="default-walkdecls" class="doc_subtitle"><span class="doc_prefix">default#</span>walkDecls()</h2><p>Traverses the container’s descendant nodes, calling callback
for each declaration node.</p>
<p>If you pass a filter, iteration will only happen over declarations
with matching properties.</p>
<pre><code class="code">root.walkDecls(<span class="code_function"><span class="code_params">decl</span> =></span> {
  checkPropertySupport(decl.prop)
})

root.walkDecls(<span class="code_string">'border-radius'</span>, <span class="code_function"><span class="code_params">decl</span> =></span> {
  decl.remove()
})

root.walkDecls(<span class="code_regexp">/^background/</span>, <span class="code_function"><span class="code_params">decl</span> =></span> {
  decl.value = takeFirstColorFromGradient(decl.value)
})</code></pre>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>propFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>(decl: default, index: number) => false | void</td><td>Iterator receives each node and index.
</td></tr></table><p>Returns <code>void | false</code>. Returns <code>false</code> if iteration was broke.
</p><h2 id="default-walkrules" class="doc_subtitle"><span class="doc_prefix">default#</span>walkRules()</h2><p>Traverses the container’s descendant nodes, calling callback
for each rule node.</p>
<p>If you pass a filter, iteration will only happen over rules
with matching selectors.</p>
<p>Like <code><a href="#container-each">Container#each</a></code>, this method is safe
to use if you are mutating arrays during iteration.</p>
<pre><code class="code"><span class="code_keyword">const</span> selectors = []
root.walkRules(<span class="code_function"><span class="code_params">rule</span> =></span> {
  selectors.push(rule.selector)
})
<span class="code_built_in">console</span>.log(<span class="code_string">`Your CSS uses <span class="code_subst">${ selectors.length }</span> selectors`</span>)</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>selectorFilter</code></td><td>string | RegExp</td><td></td></tr><tr><td><code>callback</code></td><td>(atRule: default, index: number) => false | void</td><td>Iterator receives each node and index.
</td></tr></table><p>Returns <code>void | false</code>. Returns <code>false</code> if iteration was broke.
</p><h2 id="default-warn" class="doc_subtitle"><span class="doc_prefix">default#</span>warn()</h2><p>This method is provided as a convenience wrapper for <code><a href="#result-warn">Result#warn</a></code>.</p>
<pre><code class="code">  Declaration: {
    <span class="code_attr">bad</span>: <span class="code_function">(<span class="code_params">decl, { result }</span>) =></span> {
      decl.warn(result, <span class="code_string">'Deprecated property bad'</span>)
    }
  }</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>result</code></td><td>default</td><td>The <code><a href="#result">Result</a></code> instance that will receive the warning.
</td></tr><tr><td><code>text</code></td><td>string</td><td>Warning message.
</td></tr><tr><td><code>opts</code></td><td><a href="#warningoptions">WarningOptions</a></td><td>Warning Options.
</td></tr></table></section><section class="doc"><h1 id="default" class="doc_title">default</h1><p>Represents a plugin’s warning. It can be created using <code><a href="#node-warn">Node#warn</a></code>.</p>
<pre><code class="code"><span class="code_keyword">if</span> (decl.important) {
  decl.warn(result, <span class="code_string">'Avoid !important'</span>, { <span class="code_attr">word</span>: <span class="code_string">'!important'</span> })
}</code></pre>
<h2 id="default-column" class="doc_subtitle"><span class="doc_prefix">default#</span>column</h2><p>Column in the input file with this warning’s source.</p>
<pre><code class="code">warning.column <span class="code_comment">//=> 6</span></code></pre>
<p>Type: number.</p><h2 id="default-line" class="doc_subtitle"><span class="doc_prefix">default#</span>line</h2><p>Line in the input file with this warning’s source.</p>
<pre><code class="code">warning.line <span class="code_comment">//=> 5</span></code></pre>
<p>Type: number.</p><h2 id="default-node" class="doc_subtitle"><span class="doc_prefix">default#</span>node</h2><p>Contains the CSS node that caused the warning.</p>
<pre><code class="code">warning.node.toString() <span class="code_comment">//=> 'color: white !important'</span></code></pre>
<p>Type: default.</p><h2 id="default-plugin" class="doc_subtitle"><span class="doc_prefix">default#</span>plugin</h2><p>The name of the plugin that created this warning.
When you call <code><a href="#node-warn">Node#warn</a></code> it will fill this property automatically.</p>
<pre><code class="code">warning.plugin <span class="code_comment">//=> 'postcss-important'</span></code></pre>
<p>Type: string.</p><h2 id="default-text" class="doc_subtitle"><span class="doc_prefix">default#</span>text</h2><p>The warning message.</p>
<pre><code class="code">warning.text <span class="code_comment">//=> 'Try to avoid !important'</span></code></pre>
<p>Type: string.</p><h2 id="default-type" class="doc_subtitle"><span class="doc_prefix">default#</span>type</h2><p>Type to filter warnings from <code><a href="#result-messages">Result#messages</a></code>.
Always equal to <code>"warning"</code>.</p>
<p>Type: "warning".</p><h2 id="default-tostring" class="doc_subtitle"><span class="doc_prefix">default#</span>toString()</h2><p>Returns a warning position and message.</p>
<pre><code class="code">warning.toString() <span class="code_comment">//=> 'postcss-lint:a.css:10:14: Avoid !important'</span></code></pre>
<table><tr><th>Argument</th><th>Type</th></tr></table><p>Returns <code>string</code>. Warning position and message.
</p></section><section class="doc"><h1 id="acceptedplugin" class="doc_title">AcceptedPlugin</h1><p>Type: <a href="#plugin">Plugin</a> | <a href="#plugincreator">PluginCreator</a>&lt;any> | <a href="#oldplugin">OldPlugin</a>&lt;any> | <a href="#transformcallback">TransformCallback</a> | { postcss: <a href="#transformcallback">TransformCallback</a> | default } | default.</p></section><section class="doc"><h1 id="anynode" class="doc_title">AnyNode</h1><p>Type: default | default | default | default | default.</p></section><section class="doc"><h1 id="anynode" class="doc_title">AnyNode</h1></section><section class="doc"><h1 id="atrule" class="doc_title">AtRule</h1></section><section class="doc"><h1 id="atruleprops" class="doc_title">AtRuleProps</h1><table><tr><th>Property</th><th>Type</th></tr><tr><td><code>name</code></td><td>string</td></tr><tr><td><code>nodes</code></td><td>(<a href="#atruleprops">AtRuleProps</a> | default | default | default | default | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a>)[]</td></tr><tr><td><code>params</code></td><td>string | number</td></tr><tr><td><code>raws</code></td><td><a href="#atruleraws">AtRuleRaws</a></td></tr><tr><td><code>source</code></td><td><a href="#source">Source</a></td></tr></table></section><section class="doc"><h1 id="atruleprops" class="doc_title">AtRuleProps</h1></section><section class="doc"><h1 id="atruleraws" class="doc_title">AtRuleRaws</h1><table><tr><th>Property</th><th>Type</th><th>Description</th></tr><tr><td><code>after</code></td><td>string</td><td>The space symbols after the last child of the node to the end of the node.
</td></tr><tr><td><code>afterName</code></td><td>string</td><td>The space between the at-rule name and its parameters.
</td></tr><tr><td><code>before</code></td><td>string</td><td>The space symbols before the node. It also stores <code>*</code>
and <code>_</code> symbols before the declaration (IE hack).
</td></tr><tr><td><code>between</code></td><td>string</td><td>The symbols between the last parameter and <code>{</code> for rules.
</td></tr><tr><td><code>params</code></td><td>{ raw: string, value: string }</td><td>The rule’s selector with comments.
</td></tr><tr><td><code>semicolon</code></td><td>boolean</td><td>Contains <code>true</code> if the last child has an (optional) semicolon.
</td></tr></table></section><section class="doc"><h1 id="builder" class="doc_title">Builder</h1><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>part</code></td><td>string</td></tr><tr><td><code>node</code></td><td><a href="#anynode">AnyNode</a></td></tr><tr><td><code>type</code></td><td>"start" | "end"</td></tr></table></section><section class="doc"><h1 id="childnode" class="doc_title">ChildNode</h1><p>Type: default | default | default | default.</p></section><section class="doc"><h1 id="childnode" class="doc_title">ChildNode</h1></section><section class="doc"><h1 id="childprops" class="doc_title">ChildProps</h1><p>Type: <a href="#atruleprops">AtRuleProps</a> | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a>.</p></section><section class="doc"><h1 id="childprops" class="doc_title">ChildProps</h1></section><section class="doc"><h1 id="comment" class="doc_title">Comment</h1></section><section class="doc"><h1 id="commentprops" class="doc_title">CommentProps</h1><table><tr><th>Property</th><th>Type</th></tr><tr><td><code>raws</code></td><td><a href="#commentraws">CommentRaws</a></td></tr><tr><td><code>source</code></td><td><a href="#source">Source</a></td></tr><tr><td><code>text</code></td><td>string</td></tr></table></section><section class="doc"><h1 id="commentprops" class="doc_title">CommentProps</h1></section><section class="doc"><h1 id="commentraws" class="doc_title">CommentRaws</h1><table><tr><th>Property</th><th>Type</th><th>Description</th></tr><tr><td><code>before</code></td><td>string</td><td>The space symbols before the node.
</td></tr><tr><td><code>left</code></td><td>string</td><td>The space symbols between <code>/*</code> and the comment’s text.
</td></tr><tr><td><code>right</code></td><td>string</td><td>The space symbols between the comment’s text.
</td></tr></table></section><section class="doc"><h1 id="container" class="doc_title">Container</h1></section><section class="doc"><h1 id="containerprops" class="doc_title">ContainerProps</h1><table><tr><th>Property</th><th>Type</th></tr><tr><td><code>nodes</code></td><td>(<a href="#atruleprops">AtRuleProps</a> | default | default | default | default | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a>)[]</td></tr><tr><td><code>source</code></td><td><a href="#source">Source</a></td></tr></table></section><section class="doc"><h1 id="containerprops" class="doc_title">ContainerProps</h1></section><section class="doc"><h1 id="csssyntaxerror" class="doc_title">CssSyntaxError</h1></section><section class="doc"><h1 id="declaration" class="doc_title">Declaration</h1></section><section class="doc"><h1 id="declarationprops" class="doc_title">DeclarationProps</h1><table><tr><th>Property</th><th>Type</th></tr><tr><td><code>prop</code></td><td>string</td></tr><tr><td><code>raws</code></td><td><a href="#declarationraws">DeclarationRaws</a></td></tr><tr><td><code>value</code></td><td>string</td></tr></table></section><section class="doc"><h1 id="declarationprops" class="doc_title">DeclarationProps</h1></section><section class="doc"><h1 id="declarationraws" class="doc_title">DeclarationRaws</h1><table><tr><th>Property</th><th>Type</th><th>Description</th></tr><tr><td><code>before</code></td><td>string</td><td>The space symbols before the node. It also stores <code>*</code>
and <code>_</code> symbols before the declaration (IE hack).
</td></tr><tr><td><code>between</code></td><td>string</td><td>The symbols between the property and value for declarations.
</td></tr><tr><td><code>important</code></td><td>string</td><td>The content of the important statement, if it is not just <code>!important</code>.
</td></tr><tr><td><code>value</code></td><td>{ raw: string, value: string }</td><td>Declaration value with comments.
</td></tr></table></section><section class="doc"><h1 id="fileposition" class="doc_title">FilePosition</h1><table><tr><th>Property</th><th>Type</th><th>Description</th></tr><tr><td><code>column</code></td><td>number</td><td>Column in source file.
</td></tr><tr><td><code>file</code></td><td>string</td><td>Absolute path to the source file.
</td></tr><tr><td><code>line</code></td><td>number</td><td>Line in source file.
</td></tr><tr><td><code>source</code></td><td>string</td><td>Source code.
</td></tr><tr><td><code>url</code></td><td>string</td><td>URL for the source file.
</td></tr></table></section><section class="doc"><h1 id="fileposition" class="doc_title">FilePosition</h1></section><section class="doc"><h1 id="helpers" class="doc_title">Helpers</h1><p>Type: object &amp; <a href="#postcss">Postcss</a>.</p></section><section class="doc"><h1 id="input" class="doc_title">Input</h1></section><section class="doc"><h1 id="jsonhydrator" class="doc_title">JSONHydrator</h1><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>data</code></td><td>object[]</td></tr></table><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>data</code></td><td>object</td></tr></table><p>Returns <code>default[]</code>. </p></section><section class="doc"><h1 id="lazyresult" class="doc_title">LazyResult</h1></section><section class="doc"><h1 id="message" class="doc_title">Message</h1></section><section class="doc"><h1 id="message" class="doc_title">Message</h1><table><tr><th>Property</th><th>Type</th><th>Description</th></tr><tr><td><code>plugin</code></td><td>string</td><td>Source PostCSS plugin name.
</td></tr><tr><td><code>type</code></td><td>string</td><td>Message type.
</td></tr></table></section><section class="doc"><h1 id="node" class="doc_title">Node</h1></section><section class="doc"><h1 id="nodeerroroptions" class="doc_title">NodeErrorOptions</h1><table><tr><th>Property</th><th>Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>number</td><td>An index inside a node's string that should be highlighted as source
of error.
</td></tr><tr><td><code>plugin</code></td><td>string</td><td>Plugin name that created this error. PostCSS will set it automatically.
</td></tr><tr><td><code>word</code></td><td>string</td><td>A word inside a node's string, that should be highlighted as source
of error.
</td></tr></table></section><section class="doc"><h1 id="nodeprops" class="doc_title">NodeProps</h1><table><tr><th>Property</th><th>Type</th></tr><tr><td><code>source</code></td><td><a href="#source">Source</a></td></tr></table></section><section class="doc"><h1 id="nodeprops" class="doc_title">NodeProps</h1></section><section class="doc"><h1 id="oldplugin" class="doc_title">OldPlugin</h1><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>opts</code></td><td>T</td></tr></table><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>root</code></td><td>default</td></tr><tr><td><code>result</code></td><td>default</td></tr></table><p>Returns <code><a href="#transformer">Transformer</a></code>. </p><h2 id="oldplugin-postcss" class="doc_subtitle"><span class="doc_prefix">OldPlugin#</span>postcss</h2><p>Type: <a href="#transformer">Transformer</a>.</p><h2 id="oldplugin-postcssplugin" class="doc_subtitle"><span class="doc_prefix">OldPlugin#</span>postcssPlugin</h2><p>Type: string.</p><h2 id="oldplugin-postcssversion" class="doc_subtitle"><span class="doc_prefix">OldPlugin#</span>postcssVersion</h2><p>Type: string.</p></section><section class="doc"><h1 id="parser" class="doc_title">Parser</h1><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>css</code></td><td>string | { toString: () => string }</td></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#processoptions">ProcessOptions</a>, "map" | "from"></td></tr></table><p>Returns <code>default</code>. </p></section><section class="doc"><h1 id="plugin" class="doc_title">Plugin</h1><h2 id="plugin-atrule" class="doc_subtitle"><span class="doc_prefix">Plugin#</span>AtRule</h2><p>Will be called on all<code><a href="#atrule">AtRule</a></code> nodes.</p>
<p>Will be called again on node or children changes.</p>
<p>Type: AtRuleProcessor | { [name: string]: AtRuleProcessor}.</p><h2 id="plugin-atruleexit" class="doc_subtitle"><span class="doc_prefix">Plugin#</span>AtRuleExit</h2><p>Will be called on all <code><a href="#atrule">AtRule</a></code> nodes, when all children will be processed.</p>
<p>Will be called again on node or children changes.</p>
<p>Type: AtRuleProcessor | { [name: string]: AtRuleProcessor}.</p><h2 id="plugin-comment" class="doc_subtitle"><span class="doc_prefix">Plugin#</span>Comment</h2><p>Will be called on all <code><a href="#comment">Comment</a></code> nodes.</p>
<p>Will be called again on node or children changes.</p>
<p>Type: CommentProcessor.</p><h2 id="plugin-commentexit" class="doc_subtitle"><span class="doc_prefix">Plugin#</span>CommentExit</h2><p>Will be called on all <code><a href="#comment">Comment</a></code> nodes after listeners
for <code><a href="#comment">Comment</a></code> event.</p>
<p>Will be called again on node or children changes.</p>
<p>Type: CommentProcessor.</p><h2 id="plugin-declaration" class="doc_subtitle"><span class="doc_prefix">Plugin#</span>Declaration</h2><p>Will be called on all <code><a href="#declaration">Declaration</a></code> nodes after listeners
for <code><a href="#declaration">Declaration</a></code> event.</p>
<p>Will be called again on node or children changes.</p>
<p>Type: DeclarationProcessor | { [prop: string]: DeclarationProcessor}.</p><h2 id="plugin-declarationexit" class="doc_subtitle"><span class="doc_prefix">Plugin#</span>DeclarationExit</h2><p>Will be called on all <code><a href="#declaration">Declaration</a></code> nodes.</p>
<p>Will be called again on node or children changes.</p>
<p>Type: DeclarationProcessor | { [prop: string]: DeclarationProcessor}.</p><h2 id="plugin-exit" class="doc_subtitle"><span class="doc_prefix">Plugin#</span>Exit</h2><p>Will be called when all other listeners processed the document.</p>
<p>This listener will not be called again.</p>
<p>Type: RootProcessor.</p><h2 id="plugin-once" class="doc_subtitle"><span class="doc_prefix">Plugin#</span>Once</h2><p>Will be called on <code><a href="#root">Root</a></code> node once.</p>
<p>Type: RootProcessor.</p><h2 id="plugin-onceexit" class="doc_subtitle"><span class="doc_prefix">Plugin#</span>OnceExit</h2><p>Will be called on <code><a href="#root">Root</a></code> node once, when all children will be processed.</p>
<p>Type: RootProcessor.</p><h2 id="plugin-root" class="doc_subtitle"><span class="doc_prefix">Plugin#</span>Root</h2><p>Will be called on <code><a href="#root">Root</a></code> node.</p>
<p>Will be called again on children changes.</p>
<p>Type: RootProcessor.</p><h2 id="plugin-rootexit" class="doc_subtitle"><span class="doc_prefix">Plugin#</span>RootExit</h2><p>Will be called on <code><a href="#root">Root</a></code> node, when all children will be processed.</p>
<p>Will be called again on children changes.</p>
<p>Type: RootProcessor.</p><h2 id="plugin-rule" class="doc_subtitle"><span class="doc_prefix">Plugin#</span>Rule</h2><p>Will be called on all <code><a href="#rule">Rule</a></code> nodes.</p>
<p>Will be called again on node or children changes.</p>
<p>Type: RuleProcessor.</p><h2 id="plugin-ruleexit" class="doc_subtitle"><span class="doc_prefix">Plugin#</span>RuleExit</h2><p>Will be called on all <code><a href="#rule">Rule</a></code> nodes, when all children will be processed.</p>
<p>Will be called again on node or children changes.</p>
<p>Type: RuleProcessor.</p><h2 id="plugin-postcssplugin" class="doc_subtitle"><span class="doc_prefix">Plugin#</span>postcssPlugin</h2><p>Type: string.</p><h2 id="plugin-prepare" class="doc_subtitle"><span class="doc_prefix">Plugin#</span>prepare</h2><p>Type: (result: default) => Processors.</p></section><section class="doc"><h1 id="plugincreator" class="doc_title">PluginCreator</h1><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>opts</code></td><td>PluginOptions</td></tr></table><p>Returns <code>default | <a href="#plugin">Plugin</a></code>. </p><h2 id="plugincreator-postcss" class="doc_subtitle"><span class="doc_prefix">PluginCreator#</span>postcss</h2><p>Type: true.</p></section><section class="doc"><h1 id="position" class="doc_title">Position</h1><table><tr><th>Property</th><th>Type</th><th>Description</th></tr><tr><td><code>column</code></td><td>number</td><td>Source line in file. In contrast to <code>offset</code> it starts from 1.
</td></tr><tr><td><code>line</code></td><td>number</td><td>Source column in file.
</td></tr><tr><td><code>offset</code></td><td>number</td><td>Source offset in file. It starts from 0.
</td></tr></table></section><section class="doc"><h1 id="position" class="doc_title">Position</h1></section><section class="doc"><h1 id="processoptions" class="doc_title">ProcessOptions</h1><table><tr><th>Property</th><th>Type</th><th>Description</th></tr><tr><td><code>from</code></td><td>string</td><td>The path of the CSS source file. You should always set <code>from</code>,
because it is used in source map generation and syntax error messages.
</td></tr><tr><td><code>map</code></td><td>boolean | <a href="#sourcemapoptions">SourceMapOptions</a></td><td>Source map options
</td></tr><tr><td><code>parser</code></td><td><a href="#syntax">Syntax</a> | <a href="#parser">Parser</a></td><td>Function to generate AST by string.
</td></tr><tr><td><code>stringifier</code></td><td><a href="#stringifier">Stringifier</a> | <a href="#syntax">Syntax</a></td><td>Class to generate string by AST.
</td></tr><tr><td><code>syntax</code></td><td><a href="#syntax">Syntax</a></td><td>Object with parse and stringify.
</td></tr><tr><td><code>to</code></td><td>string</td><td>The path where you'll put the output CSS file. You should always set <code>to</code>
to generate correct source maps.
</td></tr></table></section><section class="doc"><h1 id="result" class="doc_title">Result</h1></section><section class="doc"><h1 id="resultoptions" class="doc_title">ResultOptions</h1><table><tr><th>Property</th><th>Type</th><th>Description</th></tr><tr><td><code>from</code></td><td>string</td><td>The path of the CSS source file. You should always set <code>from</code>,
because it is used in source map generation and syntax error messages.
</td></tr><tr><td><code>map</code></td><td>boolean | <a href="#sourcemapoptions">SourceMapOptions</a></td><td>Source map options
</td></tr><tr><td><code>node</code></td><td>default</td><td>The CSS node that was the source of the warning.
</td></tr><tr><td><code>parser</code></td><td><a href="#syntax">Syntax</a> | <a href="#parser">Parser</a></td><td>Function to generate AST by string.
</td></tr><tr><td><code>plugin</code></td><td>string</td><td>Name of plugin that created this warning. <code><a href="#result-warn">Result#warn</a></code> will fill it
automatically with <code><a href="#plugin-postcssplugin">Plugin#postcssPlugin</a></code> value.
</td></tr><tr><td><code>stringifier</code></td><td><a href="#stringifier">Stringifier</a> | <a href="#syntax">Syntax</a></td><td>Class to generate string by AST.
</td></tr><tr><td><code>syntax</code></td><td><a href="#syntax">Syntax</a></td><td>Object with parse and stringify.
</td></tr><tr><td><code>to</code></td><td>string</td><td>The path where you'll put the output CSS file. You should always set <code>to</code>
to generate correct source maps.
</td></tr></table></section><section class="doc"><h1 id="root" class="doc_title">Root</h1></section><section class="doc"><h1 id="rootprops" class="doc_title">RootProps</h1></section><section class="doc"><h1 id="rootprops" class="doc_title">RootProps</h1><table><tr><th>Property</th><th>Type</th></tr><tr><td><code>nodes</code></td><td>(<a href="#atruleprops">AtRuleProps</a> | default | default | default | default | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a>)[]</td></tr><tr><td><code>raws</code></td><td><a href="#rootraws">RootRaws</a></td></tr><tr><td><code>source</code></td><td><a href="#source">Source</a></td></tr></table></section><section class="doc"><h1 id="rootraws" class="doc_title">RootRaws</h1><table><tr><th>Property</th><th>Type</th><th>Description</th></tr><tr><td><code>after</code></td><td>string</td><td>The space symbols after the last child to the end of file.
</td></tr><tr><td><code>semicolon</code></td><td>boolean</td><td>Is the last child has an (optional) semicolon.
</td></tr></table></section><section class="doc"><h1 id="rule" class="doc_title">Rule</h1></section><section class="doc"><h1 id="ruleprops" class="doc_title">RuleProps</h1></section><section class="doc"><h1 id="ruleprops" class="doc_title">RuleProps</h1><table><tr><th>Property</th><th>Type</th></tr><tr><td><code>nodes</code></td><td>(<a href="#atruleprops">AtRuleProps</a> | default | default | default | default | <a href="#ruleprops">RuleProps</a> | <a href="#declarationprops">DeclarationProps</a> | <a href="#commentprops">CommentProps</a>)[]</td></tr><tr><td><code>raws</code></td><td><a href="#ruleraws">RuleRaws</a></td></tr><tr><td><code>selector</code></td><td>string</td></tr><tr><td><code>selectors</code></td><td>string[]</td></tr><tr><td><code>source</code></td><td><a href="#source">Source</a></td></tr></table></section><section class="doc"><h1 id="ruleraws" class="doc_title">RuleRaws</h1><table><tr><th>Property</th><th>Type</th><th>Description</th></tr><tr><td><code>after</code></td><td>string</td><td>The space symbols after the last child of the node to the end of the node.
</td></tr><tr><td><code>before</code></td><td>string</td><td>The space symbols before the node. It also stores <code>*</code>
and <code>_</code> symbols before the declaration (IE hack).
</td></tr><tr><td><code>between</code></td><td>string</td><td>The symbols between the selector and <code>{</code> for rules.
</td></tr><tr><td><code>ownSemicolon</code></td><td>string</td><td>Contains <code>true</code> if there is semicolon after rule.
</td></tr><tr><td><code>selector</code></td><td>{ raw: string, value: string }</td><td>The rule’s selector with comments.
</td></tr><tr><td><code>semicolon</code></td><td>boolean</td><td>Contains <code>true</code> if the last child has an (optional) semicolon.
</td></tr></table></section><section class="doc"><h1 id="source" class="doc_title">Source</h1><table><tr><th>Property</th><th>Type</th><th>Description</th></tr><tr><td><code>end</code></td><td><a href="#position">Position</a></td><td>The ending position of the node's source.
</td></tr><tr><td><code>input</code></td><td>default</td><td>The file source of the node.
</td></tr><tr><td><code>start</code></td><td><a href="#position">Position</a></td><td>The starting position of the node’s source.
</td></tr></table></section><section class="doc"><h1 id="source" class="doc_title">Source</h1></section><section class="doc"><h1 id="sourcemap" class="doc_title">SourceMap</h1><p>Type: SourceMapGenerator &amp; object.</p></section><section class="doc"><h1 id="sourcemapoptions" class="doc_title">SourceMapOptions</h1><table><tr><th>Property</th><th>Type</th><th>Description</th></tr><tr><td><code>absolute</code></td><td>boolean</td><td>Use absolute path in generated source map.
</td></tr><tr><td><code>annotation</code></td><td>string | boolean | (file: string, root: default) => string</td><td>Indicates that PostCSS should add annotation comments to the CSS.
By default, PostCSS will always add a comment with a path
to the source map. PostCSS will not add annotations to CSS files
that do not contain any comments.
By default, PostCSS presumes that you want to save the source map as
<code>opts.to + '.map'</code> and will use this path in the annotation comment.
A different path can be set by providing a string value for annotation.
If you have set <code>inline: true</code>, annotation cannot be disabled.
</td></tr><tr><td><code>from</code></td><td>string</td><td>Override <code>from</code> in map’s sources.
</td></tr><tr><td><code>inline</code></td><td>boolean</td><td>Indicates that the source map should be embedded in the output CSS
as a Base64-encoded comment. By default, it is <code>true</code>.
But if all previous maps are external, not inline, PostCSS will not embed
the map even if you do not set this option.
If you have an inline source map, the result.map property will be empty,
as the source map will be contained within the text of <code>result.css</code>.
</td></tr><tr><td><code>prev</code></td><td>string | boolean | object | (file: string) => string</td><td>Source map content from a previous processing step (e.g., Sass).
PostCSS will try to read the previous source map
automatically (based on comments within the source CSS), but you can use
this option to identify it manually.
If desired, you can omit the previous map with prev: <code>false</code>.
</td></tr><tr><td><code>sourcesContent</code></td><td>boolean</td><td>Indicates that PostCSS should set the origin content (e.g., Sass source)
of the source map. By default, it is true. But if all previous maps do not
contain sources content, PostCSS will also leave it out even if you
do not set this option.
</td></tr></table></section><section class="doc"><h1 id="stringifier" class="doc_title">Stringifier</h1><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>node</code></td><td><a href="#anynode">AnyNode</a></td></tr><tr><td><code>builder</code></td><td><a href="#builder">Builder</a></td></tr></table></section><section class="doc"><h1 id="syntax" class="doc_title">Syntax</h1><table><tr><th>Property</th><th>Type</th><th>Description</th></tr><tr><td><code>parse</code></td><td><a href="#parser">Parser</a></td><td>Function to generate AST by string.
</td></tr><tr><td><code>stringify</code></td><td><a href="#stringifier">Stringifier</a></td><td>Class to generate string by AST.
</td></tr></table></section><section class="doc"><h1 id="transformcallback" class="doc_title">TransformCallback</h1><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>root</code></td><td>default</td></tr><tr><td><code>result</code></td><td>default</td></tr></table><p>Returns <code>void | Promise&lt;void></code>. </p></section><section class="doc"><h1 id="transformer" class="doc_title">Transformer</h1><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>root</code></td><td>default</td></tr><tr><td><code>result</code></td><td>default</td></tr></table><p>Returns <code>void | Promise&lt;void></code>. </p><h2 id="transformer-postcssplugin" class="doc_subtitle"><span class="doc_prefix">Transformer#</span>postcssPlugin</h2><p>Type: string.</p><h2 id="transformer-postcssversion" class="doc_subtitle"><span class="doc_prefix">Transformer#</span>postcssVersion</h2><p>Type: string.</p></section><section class="doc"><h1 id="valueoptions" class="doc_title">ValueOptions</h1><table><tr><th>Property</th><th>Type</th><th>Description</th></tr><tr><td><code>fast</code></td><td>string</td><td>String that’s used to narrow down values and speed up the regexp search.
</td></tr><tr><td><code>props</code></td><td>string[]</td><td>An array of property names.
</td></tr></table></section><section class="doc"><h1 id="warning" class="doc_title">Warning</h1></section><section class="doc"><h1 id="warningoptions" class="doc_title">WarningOptions</h1></section><section class="doc"><h1 id="warningoptions" class="doc_title">WarningOptions</h1><table><tr><th>Property</th><th>Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>number</td><td>Index in CSS node string that caused the warning.
</td></tr><tr><td><code>node</code></td><td>default</td><td>CSS node that caused the warning.
</td></tr><tr><td><code>plugin</code></td><td>string</td><td>Name of the plugin that created this warning. <code><a href="#result-warn">Result#warn</a></code> fills
this property automatically.
</td></tr><tr><td><code>word</code></td><td>string</td><td>Word in CSS source that caused the warning.
</td></tr></table></section><section class="doc"><h1 id="comment" class="doc_title">comment</h1><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>defaults</code></td><td><a href="#commentprops">CommentProps</a></td></tr></table><p>Returns <code>default</code>. </p></section><section class="doc"><h1 id="default" class="doc_title">default</h1><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>data</code></td><td>object[]</td></tr></table><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>data</code></td><td>object</td></tr></table><p>Returns <code>default[]</code>. </p></section><section class="doc"><h1 id="default" class="doc_title">default</h1><p>Type: <a href="#list">List</a>.</p></section><section class="doc"><h1 id="default" class="doc_title">default</h1><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>css</code></td><td>string | { toString: () => string }</td></tr><tr><td><code>opts</code></td><td>Pick&lt;<a href="#processoptions">ProcessOptions</a>, "map" | "from"></td></tr></table><p>Returns <code>default</code>. </p></section><section class="doc"><h1 id="default" class="doc_title">default</h1><p>Type: <a href="#postcss">Postcss</a>.</p></section><section class="doc"><h1 id="default" class="doc_title">default</h1><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>node</code></td><td><a href="#anynode">AnyNode</a></td></tr><tr><td><code>builder</code></td><td><a href="#builder">Builder</a></td></tr></table></section><section class="doc"><h1 id="fromjson" class="doc_title">fromJSON</h1><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>data</code></td><td>object[]</td></tr></table><table><tr><th>Argument</th><th>Type</th></tr><tr><td><code>data</code></td><td>object</td></tr></table><p>Returns <code>default[]</code>. </p></section><section class="doc"><h1 id="list" class="doc_title">list</h1><h2 id="list-comma" class="doc_subtitle"><span class="doc_prefix">list.</span>comma()</h2><p>Safely splits comma-separated values (such as those for <code>transition-*</code>
and <code>background</code> properties).</p>
<pre><code class="code">Once (root, { list }) {
  list.comma(<span class="code_string">'black, linear-gradient(white, black)'</span>)
  <span class="code_comment">//=> ['black', 'linear-gradient(white, black)']</span>
}</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>str</code></td><td>string</td><td>Comma-separated values.
</td></tr></table><p>Returns <code>string[]</code>. Split values.
</p><h2 id="list-space" class="doc_subtitle"><span class="doc_prefix">list.</span>space()</h2><p>Safely splits space-separated values (such as those for <code>background</code>,
<code>border-radius</code>, and other shorthand properties).</p>
<pre><code class="code">Once (root, { list }) {
  list.space(<span class="code_string">'1px calc(10% + 1px)'</span>) <span class="code_comment">//=> ['1px', 'calc(10% + 1px)']</span>
}</code></pre>
<table><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td><code>str</code></td><td>string</td><td>Space-separated values.
</td></tr></table><p>Returns <code>string[]</code>. Split values.
</p></section></main><div class="hero is-small"><a class="hero_home" rel="home" href="/"><img class="hero_logo" src="/postcss.cbfff7d9.svg" alt="PostCSS logo"></a></div><nav class="nav"><ul class="nav_items"><li class="nav_item"><a class="nav_link" href="https://github.com/postcss/postcss#usage">Setup</a></li><li class="nav_item"><a class="nav_link" href="https://github.com/postcss/postcss/tree/main/docs">Docs</a></li><li class="nav_item"><a class="nav_link" href="http://postcss.parts/">Plugins</a></li><li class="nav_item"><a class="nav_link" href="http://postcss.org/api/">API</a></li><li class="nav_item"><a class="nav_link" href="https://github.com/postcss/brand">Logo</a></li></ul></nav><aside class="socials"><ul class="socials_items"><li class="socials_item"><a class="is-open-collective socials_link" href="https://opencollective.com/postcss/" rel="me">Open Collective</a></li><li class="socials_item"><a class="is-twitter socials_link" href="https://twitter.com/postcss" rel="me">Twitter</a></li><li class="socials_item"><a class="is-gitter socials_link" href="https://gitter.im/postcss/postcss" rel="me">Gitter</a></li><li class="socials_item"><a class="is-github socials_link" href="https://github.com/postcss/postcss" rel="me">GitHub</a></li></ul></aside><footer class="footer"><div class="footer_inner"><div class="footer_info"><p class="footer_license">Distributed under the MIT License.</p><p class="footer_issue">Found an issue?<a class="footer_report" href="https://github.com/postcss/postcss.org/issues">Report it!</a></p></div><div><a href="https://evilmartians.com/?utm_source=postcss&amp;utm_campaign=homepage"><img alt="Evil Martians" src="/evilmartians.f78bd1eb.svg"></a></div></div></footer></body></html>